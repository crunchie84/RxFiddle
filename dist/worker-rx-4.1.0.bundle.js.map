{"version":3,"sources":["webpack:///dist/worker-rx-4.1.0.bundle.js","webpack:///webpack/bootstrap 19911d4006b8129424bd?3419*","webpack:///external \"Rx\"?442b*","webpack:///./src/experiment/sample-data.ts","webpack:///./src/instrumentation/worker-utils.ts","webpack:///./src/instrumentation/rxjs-4.1.0/collector.ts","webpack:///./src/instrumentation/rxjs-4.1.0/instrumentation.ts","webpack:///./src/instrumentation/rxjs-4.1.0/worker.ts","webpack:///./src/collector/collector.ts?d603*","webpack:///./src/collector/callrecord.ts?e81e","webpack:///./src/collector/event.ts?a5b4","webpack:///./src/utils.ts?55fd*","webpack:///(webpack)/buildin/global.js?3698*","webpack:///./src/collector/treePoster.ts","webpack:///./src/oct/oct.ts?f3d9*","webpack:///./src/collector/logger.ts?4f8b","webpack:///./src/prelude.ts?4065*"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","1","Rx","10","global","scheduler","_","next","ReactiveTest","onNext","complete","onCompleted","experimentProto","TestScheduler","advanceTo","bmi","height$","this","createHotObservable","map","v","concat","weight$","lottery","_this","newYear$","Observable","interval","survey","t","Date","UTC","veryOldServer","date","getTime","Math","pow","throw","Error","msg","winningTicket","round","random","imdb","_this2","inputStream","text","_scheduler","messages","length","shift","push","slice","apply","_movies","findMoviesAsync","term","result","filter","movie","toLowerCase","indexOf","johnsInput$","render","renderSomething","log","showError","noop","eval","experiment","11","formatError","e","message","original","undefined","stack","toString","scopedEval","code","scope","evalAndRepackageErrors","type","dummyError","exec","error","index","lastIndexOf","substring","split","join","onWorkerMessage","instrument","data","importScripts","url","postMessage","113","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","Constructor","TypeError","_getScheduler","obs","record","arguments","collector_1","isScheduler","callStackDepth","parent","generate","seed","sequenceUnique","keySelector","list","filtered","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","_typeof","obj","constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","callrecord_1","event_1","logger_1","oct_1","prelude_1","debug","SequenceTicker","last","used","TreeCollector","logger","nextId","eventSequencer","schedulers","collectorId","hash","fn","self","isObservable","subject","replacementLambda","observableWrapper","returned","__original","method","action","state","info","tag","startsWith","justAssigned","parents","callRecordType","tagObservable","isObserver","subscriptionWrapper","tagObserver","flatMap","forEach","sub","observable","SubjectTree","addSink","setObservable","ObservableTree","r","hasTag","id","observer","event","events","inflow","timing","getTiming","addEvent","isDisposable","disposableWrapper","input","tree","getScheduler","ObserverTree","getPrototype","console","clock","now","SchedulerInfo","clocks","tick","assign","_this3","traverse","getSink","_ref","_ref2","sink","setSink","_this4","elvis","rec","_ref3","_ref4","how","callRecord","_this5","wasTagged","addMeta","calls","args","formatArguments","source","setSources","_sources","context","outerContext","subscribe","Proxy","__isSubscriptionWrapper","proxy","collector","Event","fromCall","__isDisposableWrapper","114","performance","hasRxObservablePrototype","rxAny","isPrototypeOf","matcher","substr","detachedScopeProxy","hashes","__detached","set","rxTweaks","fields","a","prop","__proto__","defaultSubjects","Observable.prototype","ConnectableObservable.prototype","ConnectableObservable","ObservableBase.prototype","ObservableBase","Subject.prototype","Subject","defaultSchedulerFactory","keys","Scheduler","reduce","HASH","IGNORE","Instrumentation","subjects","open","stackTraces","prototypes","by","__originalFunction","isInstrumented","__instrumentedBy","orig","extras","thisArg","argumentsList","setupPrototype","childs","subjectName","time","instanceLogger","before","wrapHigherOrder","bind","end","after","pop","construct","warn","Function","deinstrument","methodName","setupSchedulerMethods","setupSchedulerPrototype","schedule","proto","_newAction","newAction","schedulerPrototype","argArray","newTarget","__dynamicallyInstrumented","methods","prev","default","120","treePoster_1","worker_utils_1","instrumentation_1","onmessage","poster","setup","version","22","dispose","item","path","25","26","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","Next","ErrorInstance","Complete","Connect","Subscribe","Dispose","_Event","getPrototypeOf","someError","_Event2","_Event3","_Event4","_Event5","_Event6","3","getName","funcNameRegex","results","UUID","replace","4","g","window","46","TreePoster","cb","post","location","origin","meta","w","nodes","contract","5","pad","str","depth","_inspect","opts","inspect","names","addNode","sources","addEdge","label","sinks","addInflow","outer","derivedCtor","baseCtors","baseCtor","getOwnPropertyNames","addScheduler","6","formatObject","levels","padding","_formatArguments","Logger","7","f","endsWith","suffix","head","protoype"],"mappings":"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","file":"./dist/worker-rx-4.1.0.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 120);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = Rx;\n\n/***/ }),\n\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scheduler = null;\nvar _ = {\n    get next() {\n        return Rx.ReactiveTest.onNext;\n    },\n    get complete() {\n        return Rx.ReactiveTest.onCompleted;\n    }\n};\nvar experimentProto = {\n    get scheduler() {\n        if (scheduler === null) {\n            scheduler = new Rx.TestScheduler();\n            scheduler.advanceTo(0);\n        }\n        return scheduler;\n    },\n    get bmi() {\n        return {\n            height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(400)])),\n            weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(700)]))\n        };\n    },\n    get lottery() {\n        var _this = this;\n\n        var start = 2034;\n        var year = 1000 * 3600 * 24 * 365.25;\n        return {\n            newYear$: Rx.Observable.interval(year, survey.scheduler).map(function (t) {\n                return new Date(Date.UTC(t + start, 0, 1));\n            }),\n            veryOldServer: function veryOldServer(date) {\n                var unix = new Date(date).getTime() / 1000;\n                if (unix > Math.pow(2, 31)) {\n                    return Rx.Observable.throw(new Error(\"Crash!\"), _this.scheduler);\n                } else {\n                    return _this.scheduler.createHotObservable(_.next(0, { msg: \"calculating\" }), _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }), _.complete(20));\n                }\n            }\n        };\n    },\n    get imdb() {\n        var _this2 = this;\n\n        var inputStream = function inputStream(text) {\n            var _scheduler;\n\n            var t = 0;\n            var messages = [];\n            // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n            var random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89, 70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24, 15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33, 0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64, 96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3];\n            for (var i = 0; i <= text.length; i++) {\n                t += random.shift();\n                messages.push(_.next(t, text.slice(0, i)));\n            }\n            return (_scheduler = _this2.scheduler).createHotObservable.apply(_scheduler, messages);\n        };\n        return {\n            _movies: [\"Them\", \"Lion King\", \"Belle & The Beast\", \"Avatar\", \"Harry Potter\", \"Guardians of the Galaxy\", \"House of Cards\", \"Spectre\", \"Interstellar\", \"Iron Man\", \"Terminator Genisys\", \"The Titanic\", \"The Avengers\"],\n            findMoviesAsync: function findMoviesAsync(term) {\n                var result = _this2.imdb._movies.filter(function (movie) {\n                    return movie.toLowerCase().indexOf(term.toLowerCase()) >= 0;\n                });\n                var t = 100 * result.length;\n                return _this2.scheduler.createHotObservable(_.next(t, result), _.complete(t + 1));\n            },\n            inputStream: inputStream,\n            johnsInput$: inputStream(\"the titanic\"),\n            render: function render() {}\n        };\n    },\n    get render() {\n        return function () {};\n    },\n    get renderSomething() {\n        return function () {};\n    },\n    get log() {\n        return function () {};\n    },\n    get showError() {\n        return function () {};\n    },\n    get noop() {\n        return function () {};\n    }\n};\neval(\"var experiment = experimentProto\");\nglobal.experiment = experimentProto;\neval(\"var survey = experimentProto\");\nglobal.survey = experimentProto;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction formatError(e) {\n    return {\n        message: e.message,\n        name: e.name,\n        original: typeof e.original !== \"undefined\" ? formatError(e.original) : undefined,\n        stack: e.stack.toString()\n    };\n}\nvar scope = {};\n/**\n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand\n * and strip that from the errors coming from it\n */\nfunction scopedEval(code) {\n    // tslint:disable-next-line:only-arrow-functions\n    (function () {\n        // tslint:disable-next-line:no-eval\n        return eval(code);\n    }).call(scope);\n}\nfunction evalAndRepackageErrors(code) {\n    try {\n        return { result: scopedEval(code), type: \"result\" };\n    } catch (e) {\n        // Infer eval location\n        try {\n            scopedEval(\"throw new Error('ERROR')\");\n        } catch (dummyError) {\n            // clean up error stack trace\n            var result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack);\n            if (result === null) {\n                return { error: e.stack, type: \"error\" };\n            }\n            var stack = e.stack.toString();\n            var index = stack.lastIndexOf(\"at Object.<anonymous> (\" + result[1] + \")\");\n            stack = stack.substring(0, index);\n            stack = stack.split(\"eval at <anonymous> (\" + result[1] + \"), \").join(\"\");\n            e.stack = stack;\n        }\n        return { error: formatError(e), type: \"error\" };\n    }\n}\nfunction onWorkerMessage(instrument) {\n    return function (e) {\n        var message = e.data;\n        switch (message.type) {\n            case \"importScripts\":\n                importScripts(message.url);\n                instrument();\n                break;\n            case \"run\":\n                // Execute user code\n                var result = evalAndRepackageErrors(message.code);\n                if (result.type === \"error\") {\n                    postMessage({\n                        error: result.error,\n                        type: \"error\"\n                    });\n                }\n                break;\n            default:\n                break;\n        }\n    };\n}\nexports.onWorkerMessage = onWorkerMessage;\nif (typeof postMessage === \"function\") {\n    postMessage(\"ready\");\n}\n\n/***/ }),\n\n/***/ 113:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar callrecord_1 = __webpack_require__(25);\nvar collector_1 = __webpack_require__(22);\nvar event_1 = __webpack_require__(26);\nvar logger_1 = __webpack_require__(6);\nvar oct_1 = __webpack_require__(5);\nvar prelude_1 = __webpack_require__(7);\nvar debug = false;\nfunction _getScheduler(obs, record) {\n    return obs.scheduler || obs._scheduler || record && [].slice.call(record.arguments, -1).filter(collector_1.isScheduler)[0];\n}\n\nvar SequenceTicker = function () {\n    function SequenceTicker() {\n        _classCallCheck(this, SequenceTicker);\n\n        this.last = 0;\n        this.used = false;\n    }\n\n    _createClass(SequenceTicker, [{\n        key: \"next\",\n        value: function next() {\n            if (this.used) {\n                this.used = false;\n                this.last++;\n            }\n        }\n    }, {\n        key: \"get\",\n        value: function get() {\n            this.used = true;\n            return this.last;\n        }\n    }]);\n\n    return SequenceTicker;\n}();\n\nvar TreeCollector = function () {\n    function TreeCollector(logger) {\n        _classCallCheck(this, TreeCollector);\n\n        this.nextId = 1;\n        this.eventSequencer = new SequenceTicker();\n        this.schedulers = [];\n        this.collectorId = TreeCollector.collectorId++;\n        this.hash = this.collectorId ? \"__thash\" + this.collectorId : \"__thash\";\n        this.logger = logger;\n    }\n    /**\n     * Used to wrap arguments of higher order functions. Consider:\n     *\n     *   let a = Rx.Observable.just(1)\n     *   a.flatMap((nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n     *\n     * now wrapHigherOrder is called like this:\n     *\n     *   wrapHigherOrder(a, (nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n     *\n     * so we can inject a custom function which can link the result of the lambda to `a`.\n     *\n     * @param subject observable to link to\n     * @param fn function (or any other argument) to wrap\n     */\n\n\n    _createClass(TreeCollector, [{\n        key: \"wrapHigherOrder\",\n        value: function wrapHigherOrder(call, fn) {\n            var self = this;\n            if (typeof fn === \"function\" && collector_1.isObservable(call.subject)) {\n                var replacementLambda = function replacementLambda() {\n                    var result = fn.apply(this, arguments);\n                    if ((typeof result === \"undefined\" ? \"undefined\" : _typeof(result)) === \"object\" && collector_1.isObservable(result)) {\n                        return self.observableWrapper(result, call.subject, function () {\n                            return call.returned;\n                        });\n                    }\n                    return result;\n                };\n\n                replacementLambda.__original = fn;\n                return replacementLambda;\n            }\n            return fn;\n        }\n    }, {\n        key: \"schedule\",\n        value: function schedule(scheduler, method, action, state) {\n            var info = this.tag(scheduler);\n            var self = this;\n            if (method.startsWith(\"schedule\") && method !== \"scheduleRequired\") {\n                // tslint:disable-next-line:only-arrow-functions\n                return function () {\n                    var justAssigned = self.scheduler = { scheduler: scheduler, info: info };\n                    self.eventSequencer.next();\n                    var result = action.apply(this, arguments);\n                    if (self.scheduler === justAssigned) {\n                        self.scheduler = undefined;\n                    }\n                    return result;\n                };\n            }\n        }\n    }, {\n        key: \"before\",\n        value: function before(record, parents) {\n            var _this = this;\n\n            switch (callrecord_1.callRecordType(record)) {\n                case \"subscribe\":\n                    var obs = this.tagObservable(record.subject);\n                    [].slice.call(record.arguments, 0, 1).filter(collector_1.isObserver).map(function (s) {\n                        record.arguments[0] = _this.subscriptionWrapper(record.arguments[0], _this.tagObserver(s, record)[0]);\n                        return s;\n                    }).flatMap(function (s) {\n                        return _this.tagObserver(s, record);\n                    }).forEach(function (sub) {\n                        obs.forEach(function (observable) {\n                            if (observable instanceof oct_1.SubjectTree) {\n                                // Special case for subjects\n                                observable.addSink([sub], \" subject\");\n                                sub.setObservable([observable]);\n                            } else if (observable instanceof oct_1.ObservableTree) {\n                                sub.setObservable([observable]);\n                            }\n                        });\n                    });\n                    break;\n                case \"setup\":\n                    this.tagObservable(record.subject);\n                default:\n                    break;\n            }\n            return this;\n        }\n    }, {\n        key: \"getEventReason\",\n        value: function getEventReason(record) {\n            var _this2 = this;\n\n            return [record.parent, record.parent && record.parent.parent].filter(function (r) {\n                return r && collector_1.isObserver(r.subject) && _this2.hasTag(r.subject);\n            }).map(function (r) {\n                return _this2.tag(r.subject).id;\n            })[0];\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(observer, event, value) {\n            if (typeof event === \"undefined\") {\n                return;\n            }\n            // Enrich higher order events\n            if (event.type === \"next\" && collector_1.isObservable(value)) {\n                event.value = {\n                    id: this.tag(value).id,\n                    type: value.constructor.name\n                };\n            }\n            // Ignore 2nd subscribe (subscribe & _subscribe are instrumented both)\n            if (observer.events.length === 1 && observer.events[0].type === \"subscribe\" && event.type === \"subscribe\") {\n                return;\n            }\n            if (!observer.inflow || observer.inflow.length === 0) {\n                this.eventSequencer.next();\n            }\n            event.timing = this.getTiming();\n            observer.addEvent(event);\n        }\n    }, {\n        key: \"after\",\n        value: function after(record) {\n            switch (callrecord_1.callRecordType(record)) {\n                case \"subscribe\":\n                    if (collector_1.isDisposable(record.returned)) {\n                        record.returned = this.disposableWrapper(record.returned, record.arguments[0]);\n                    }\n                    break;\n                case \"setup\":\n                    this.tagObservable(record.returned, record);\n                default:\n                    break;\n            }\n        }\n    }, {\n        key: \"hasTag\",\n        value: function hasTag(input) {\n            return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && input !== null && typeof input[this.hash] !== \"undefined\";\n        }\n    }, {\n        key: \"tag\",\n        value: function tag(input, record) {\n            var tree = void 0;\n            if (typeof input === \"undefined\") {\n                return undefined;\n            }\n            if (typeof input[this.hash] !== \"undefined\") {\n                return input[this.hash];\n            }\n            if (collector_1.isObserver(input) && collector_1.isObservable(input)) {\n                input[this.hash] = tree = new oct_1.SubjectTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input));\n                return tree;\n            }\n            if (collector_1.isObservable(input)) {\n                input[this.hash] = tree = new oct_1.ObservableTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input, record));\n                return tree;\n            }\n            if (collector_1.isObserver(input)) {\n                input[this.hash] = tree = new oct_1.ObserverTree(\"\" + this.nextId++, input.constructor.name, this.logger);\n                return tree;\n            }\n            if (collector_1.isScheduler(input)) {\n                var scheduler = input;\n                var type = void 0;\n                switch (prelude_1.getPrototype(scheduler).constructor.name) {\n                    case \"ImmediateScheduler\":\n                        type = \"immediate\";\n                        break;\n                    case \"DefaultScheduler\":\n                        type = \"timeout\";\n                        break;\n                    case \"CurrentThreadScheduler\":\n                        type = \"recursive\";\n                        break;\n                    case \"TestScheduler\":\n                        type = \"virtual\";\n                        break;\n                    default:\n                        if (debug) {\n                            console.debug(\"unknown scheduler type\", prelude_1.getPrototype(scheduler).constructor.name);\n                        }\n                        type = \"virtual\";\n                        break;\n                }\n                var clock = scheduler.now();\n                var info = new oct_1.SchedulerInfo(\"\" + this.nextId++, prelude_1.getPrototype(scheduler).constructor.name, type, clock, this.logger);\n                input[this.hash] = info;\n                this.schedulers.push({ scheduler: scheduler, info: info });\n                return info;\n            }\n        }\n    }, {\n        key: \"getScheduler\",\n        value: function getScheduler(input, record) {\n            if (collector_1.isObservable(input) && _getScheduler(input, record)) {\n                return this.tag(_getScheduler(input, record));\n            }\n        }\n    }, {\n        key: \"getTiming\",\n        value: function getTiming() {\n            var clocks = { tick: this.eventSequencer.get() };\n            if (this.scheduler) {\n                clocks[this.scheduler.info.id] = this.scheduler.scheduler.now();\n                return Object.assign({\n                    scheduler: this.scheduler.info.id,\n                    clocks: clocks\n                });\n            }\n            return {\n                clocks: clocks,\n                scheduler: \"tick\"\n            };\n        }\n    }, {\n        key: \"tagObserver\",\n        value: function tagObserver(input, record) {\n            var _this3 = this;\n\n            var traverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (collector_1.isObserver(input)) {\n                // Rx specific: unfold AutoDetachObserver's, \n                while (traverse && input && input.constructor.name === \"AutoDetachObserver\" && input.observer) {\n                    input = input.observer;\n                }\n                var tree = this.tag(input);\n                // Find sink\n                var sinks = this.getSink(input, record);\n                sinks.forEach(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        how = _ref2[0],\n                        sink = _ref2[1];\n\n                    tree.setSink([_this3.tag(sink)]);\n                });\n                return [tree];\n            }\n            return [];\n        }\n    }, {\n        key: \"getSink\",\n        value: function getSink(input, record) {\n            var _this4 = this;\n\n            // Rx specific: InnerObservers have references to their sinks via a AutoDetachObserver\n            var list = collector_1.elvis(input, [\"o\", \"observer\"]) // InnerObservers\n            .concat(collector_1.elvis(input, [\"_o\", \"observer\"])) // InnerObservers\n            .concat(collector_1.elvis(input, [\"parent\"])) // what was this again?\n            .concat(collector_1.elvis(input, [\"_s\", \"o\"])) // ConcatObserver\n            .concat(collector_1.elvis(input, [\"observer\"])) // ConcatObserver\n            .map(function (s) {\n                return [\" via o.observer\", s];\n            });\n            // If no sinks could be found via object attributes, try to find it via the call stack\n            if (record && !list.length && callStackDepth(record) > 2 && !(collector_1.isObservable(input) && collector_1.isObserver(input))) {\n                list.push.apply(list, _toConsumableArray(sequenceUnique(function (_) {\n                    return _.sub;\n                }, generate(record, function (_) {\n                    return _.parent;\n                }).map(function (rec) {\n                    return {\n                        sub: rec.arguments[0]\n                    };\n                }).filter(function (_) {\n                    return collector_1.isObserver(_.sub) && _.sub !== input;\n                })).slice(1, 2).map(function (_) {\n                    return [\" via callstack\", _.sub];\n                })));\n            }\n            return list.slice(0, 1).flatMap(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    how = _ref4[0],\n                    sink = _ref4[1];\n\n                if (sink.constructor.name === \"AutoDetachObserver\") {\n                    return _this4.getSink(sink);\n                } else {\n                    return [[how, sink]];\n                }\n            });\n        }\n    }, {\n        key: \"tagObservable\",\n        value: function tagObservable(input, callRecord) {\n            var _this5 = this;\n\n            if (collector_1.isObservable(input)) {\n                var wasTagged = this.hasTag(input);\n                var tree = this.tag(input, callRecord);\n                if (!wasTagged) {\n                    /* TODO find other way: this is a shortcut to prevent MulticastObservable._fn1 to show up */\n                    if (callRecord && callRecord.method[0] !== \"_\") {\n                        while (callRecord && collector_1.isObservable(callRecord.returned) && callRecord.method[0] !== \"_\") {\n                            tree.addMeta({\n                                calls: {\n                                    subject: \"callRecord.subjectName \" + (this.hasTag(callRecord.subject) && this.tag(callRecord.subject).id),\n                                    args: logger_1.formatArguments(callRecord.arguments),\n                                    method: callRecord.method\n                                }\n                            });\n                            // if (typeof callRecord.parent !== \"undefined\" && isObservable(callRecord.parent.subject)) {\n                            callRecord = callRecord.parent;\n                            // } else {\n                            //   callRecord = undefined\n                            // }\n                        }\n                    }\n                    if (input.source) {\n                        tree.setSources(this.tagObservable(input.source));\n                    } else if (input._sources) {\n                        tree.setSources(input._sources.flatMap(function (s) {\n                            return _this5.tagObservable(s);\n                        }));\n                    }\n                }\n                if (_getScheduler(input)) {\n                    this.tag(_getScheduler(input));\n                }\n                return [tree];\n            }\n            return [];\n        }\n    }, {\n        key: \"observableWrapper\",\n        value: function observableWrapper(target, context, outerContext) {\n            function subscribe() {\n                if (debug) {\n                    console.debug(\"Wrap this higher order subscribe method\\n\", target.constructor.name, context.constructor.name, outerContext().constructor.name);\n                }\n                var result = target.subscribe.apply(target, arguments);\n                return result;\n            }\n            return new Proxy(target, {\n                get: function get(obj, name) {\n                    if (name === \"isScoped\") {\n                        return true;\n                    }\n                    if (name === \"subscribe\" && \"subscribe\" in target) {\n                        return subscribe;\n                    }\n                    return obj[name];\n                }\n            });\n        }\n        // Wrap this around a Subscription to log onNext, onError, onComplete, dispose calls\n\n    }, {\n        key: \"subscriptionWrapper\",\n        value: function subscriptionWrapper(target, tree) {\n            if (target.__isSubscriptionWrapper) {\n                return target;\n            }\n            // Ensure only one single Proxy is attached to the IObserverTree\n            if (tree.proxy) {\n                return target;\n            }\n            var collector = this;\n            var events = [\"onNext\", \"onError\", \"onCompleted\", \"dispose\"];\n            tree.addEvent(event_1.Event.fromCall(\"subscribe\", undefined, this.getTiming()));\n            var proxy = new Proxy(target, {\n                get: function get(obj, name) {\n                    var original = obj[name];\n                    if (name === \"__isSubscriptionWrapper\") {\n                        return true;\n                    }\n                    if (typeof original === \"function\" && events.indexOf(name) >= 0) {\n                        var _proxy = function _proxy() {\n                            collector.addEvent(tree, event_1.Event.fromCall(name, [].slice.call(arguments, 0), undefined), arguments[0]);\n                            return original.apply(this, arguments);\n                        };\n\n                        return _proxy;\n                    }\n                    return original;\n                }\n            });\n            tree.proxy = proxy;\n            return proxy;\n        }\n        // Wrap this around a Disposable to log dispose calls onto the supplied observer\n\n    }, {\n        key: \"disposableWrapper\",\n        value: function disposableWrapper(target, observer) {\n            if (target.__isDisposableWrapper) {\n                return target;\n            }\n            var tree = collector_1.isObserver(observer) ? this.tagObserver(observer) : [];\n            var collector = this;\n            return new Proxy(target, {\n                get: function get(obj, name) {\n                    var original = obj[name];\n                    if (name === \"__isDisposableWrapper\") {\n                        return true;\n                    }\n                    if (typeof original === \"function\" && name === \"dispose\") {\n                        var proxy = function proxy() {\n                            collector.addEvent(tree[0], event_1.Event.fromCall(name, [].slice.call(arguments, 0), undefined));\n                            return original.apply(this, arguments);\n                        };\n\n                        return proxy;\n                    }\n                    return original;\n                }\n            });\n        }\n    }]);\n\n    return TreeCollector;\n}();\n\nTreeCollector.collectorId = 0;\nexports.TreeCollector = TreeCollector;\nfunction callStackDepth(record) {\n    return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent);\n}\nfunction generate(seed, next) {\n    if (typeof seed === \"undefined\" || seed === null) {\n        return [];\n    } else {\n        return [seed].concat(_toConsumableArray(generate(next(seed), next)));\n    }\n}\nfunction sequenceUnique(keySelector, list) {\n    var filtered = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var v = _step.value;\n\n            if (filtered.length === 0 || keySelector(filtered[filtered.length - 1]) !== keySelector(v)) {\n                filtered.push(v);\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return filtered;\n}\n\n/***/ }),\n\n/***/ 114:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(3);\nvar Rx = __webpack_require__(1);\nvar rxAny = Rx;\nexports.defaultSubjects = function (rxAny) {\n    return {\n        Observable: Rx.Observable,\n        \"Observable.prototype\": rxAny.Observable.prototype,\n        \"ConnectableObservable.prototype\": rxAny.ConnectableObservable.prototype,\n        \"ObservableBase.prototype\": rxAny.ObservableBase.prototype,\n        // \"AbstractObserver.prototype\": rxAny.internals.AbstractObserver.prototype,\n        // \"AnonymousObserver.prototype\": rxAny.AnonymousObserver.prototype,\n        \"Subject.prototype\": rxAny.Subject.prototype\n    };\n};\nexports.defaultSchedulerFactory = Object.keys(Rx.Scheduler).filter(function (name) {\n    return _typeof(Rx.Scheduler[name]) === \"object\";\n}).filter(function (name) {\n    return Rx.Scheduler[name].__proto__.constructor.name.indexOf(\"Scheduler\") >= 0;\n}).reduce(function (p, name) {\n    p[name] = Rx.Scheduler[name];\n    return p;\n}, {});\nexports.HASH = \"__hash\";\nexports.IGNORE = \"__ignore\";\nfunction now() {\n    return typeof performance !== \"undefined\" ? performance.now() : new Date().getTime();\n}\nfunction hasRxObservablePrototype(input) {\n    return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && rxAny.Observable.prototype.isPrototypeOf(input);\n}\nfunction startsWith(input, matcher) {\n    var r = input.substr(0, matcher.length) === matcher;\n    return r;\n}\nfunction detachedScopeProxy(input) {\n    var hashes = {};\n    if (input.__detached === true) {\n        return input;\n    }\n    return new Proxy(input, {\n        get: function get(target, property) {\n            if (property === \"__detached\") {\n                return true;\n            }\n            if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n                return hashes[property];\n            }\n            return target[property];\n        },\n        set: function set(target, property, value) {\n            if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n                hashes[property] = value;\n            }\n            return true;\n        }\n    });\n}\n/**\n * Tweaks specific for RxJS 4\n */\nfunction rxTweaks(call) {\n    // Detach reuse of NeverObservable\n    var fields = [];\n    fields.push([call, \"subject\"], [call, \"returned\"]);\n    fields.push.apply(fields, _toConsumableArray([].map.call(call.arguments, function (a, i) {\n        return [call.arguments, i];\n    })));\n    fields.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            subject = _ref2[0],\n            prop = _ref2[1];\n\n        if (typeof subject[prop] !== \"undefined\" && subject[prop] !== null && subject[prop].constructor.name === \"NeverObservable\") {\n            subject[prop] = detachedScopeProxy(subject[prop]);\n        }\n    });\n    // Other tweaks here...\n}\n// class Ticker {\n//   private tick: number = 0\n//   private timeout?: Rx.IDisposable\n//   private next: () => void\n//   constructor() {\n//     this.next = this.nextTick.bind(this)\n//   }\n//   public get() {\n//     if (!this.timeout) {\n//       this.timeout = Rx.Scheduler.currentThread.schedule({}, () => { this.next(); return Rx.Disposable.empty })\n//       // this.timeout = setTimeout(this.next, 0)\n//     }\n//     return this.tick\n//   }\n//   private nextTick() {\n//     this.tick++\n//     this.timeout = undefined\n//   }\n// }\n// let ticker = new Ticker()\nfunction getPrototype(input) {\n    return input.prototype || input.__proto__;\n}\nexports.getPrototype = getPrototype;\nvar i = 0;\n\nvar Instrumentation = function () {\n    function Instrumentation() {\n        var subjects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.defaultSubjects;\n        var logger = arguments[1];\n\n        _classCallCheck(this, Instrumentation);\n\n        this.open = [];\n        this.stackTraces = true;\n        this.calls = [];\n        this.prototypes = [];\n        this.subjects = subjects;\n        this.logger = logger;\n        Object.keys(subjects).slice(0, 1).forEach(function (s) {\n            return subjects[s][exports.IGNORE] = true;\n        });\n    }\n\n    _createClass(Instrumentation, [{\n        key: \"isInstrumented\",\n        value: function isInstrumented(fn, by) {\n            if (typeof by === \"undefined\") {\n                return typeof fn.__originalFunction === \"function\" ? 1 + this.isInstrumented(fn.__originalFunction) : 0;\n            }\n            if (fn.__instrumentedBy === by) {\n                return true;\n            }\n            var orig = fn.__originalFunction;\n            return typeof orig === \"function\" && this.isInstrumented(orig, by);\n        }\n        /* tslint:disable:only-arrow-functions */\n        /* tslint:disable:no-string-literal */\n        /* tslint:disable:no-string-literal */\n\n    }, {\n        key: \"instrument\",\n        value: function instrument(fn, extras) {\n            var _this = this;\n\n            var calls = this.calls;\n            var logger = this.logger;\n            var open = this.open;\n            var self = this;\n            var instrumented = new Proxy(fn, {\n                apply: function apply(target, thisArg, argumentsList) {\n                    // console.log(target.caller)\n                    // find more\n                    argumentsList.filter(hasRxObservablePrototype).filter(function (v) {\n                        return !_this.isInstrumented(v);\n                    }).forEach(function (t) {\n                        return _this.setupPrototype(t);\n                    });\n                    var call = {\n                        arguments: [].slice.call(argumentsList, 0),\n                        childs: [],\n                        id: i++,\n                        method: extras[\"methodName\"],\n                        stack: self.stackTraces ? undefined : undefined,\n                        subject: thisArg,\n                        subjectName: extras[\"subjectName\"],\n                        tick: 0,\n                        time: now()\n                    };\n                    // Prepare\n                    calls.push(call);\n                    if (open.length > 0) {\n                        call.parent = open[open.length - 1];\n                        call.parent.childs.push(call);\n                    }\n                    open.push(call);\n                    // Nicen up Rx performance tweaks\n                    rxTweaks(call);\n                    // Actual method\n                    var instanceLogger = logger.before(call, open.slice(0, -1));\n                    var returned = target.apply(call.subject, [].map.call(call.arguments, instanceLogger.wrapHigherOrder.bind(instanceLogger, call)));\n                    var end = call;\n                    end.returned = returned;\n                    // Nicen up Rx performance tweaks\n                    rxTweaks(end);\n                    instanceLogger.after(end);\n                    // find more\n                    [end.returned].filter(hasRxObservablePrototype).filter(function (v) {\n                        return !_this.isInstrumented(v);\n                    }).forEach(function (t) {\n                        return _this.setupPrototype(t);\n                    });\n                    // Cleanup\n                    open.pop();\n                    return end.returned;\n                },\n                construct: function construct(target, args) {\n                    console.warn(\"TODO, instrument constructor\", target, args);\n                    return new (Function.prototype.bind.apply(target, [null].concat(_toConsumableArray(args))))();\n                },\n                get: function get(target, property) {\n                    if (property === \"__instrumentedBy\") {\n                        return self;\n                    }\n                    if (property === \"__originalFunction\") {\n                        return fn;\n                    }\n                    return target[property];\n                }\n            });\n            return instrumented;\n        }\n    }, {\n        key: \"deinstrument\",\n        value: function deinstrument(fn) {\n            return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn;\n        }\n        /* tslint:enable:only-arrow-functions */\n        /* tslint:enable:no-string-literal */\n        /* tslint:enable:no-string-literal */\n\n    }, {\n        key: \"setup\",\n        value: function setup() {\n            var _this2 = this;\n\n            // Observables\n            Object.keys(this.subjects).forEach(function (name) {\n                return _this2.setupPrototype(_this2.subjects[name], name);\n            });\n            // Subjects\n            rxAny.Subject = this.instrument(rxAny.Subject, {\n                methodName: \"new\",\n                subjectName: \"Rx.Subject\"\n            });\n            // Schedulers\n            Object.keys(exports.defaultSchedulerFactory).forEach(function (name) {\n                return _this2.setupSchedulerMethods(exports.defaultSchedulerFactory[name], name);\n            });\n            rxAny.TestScheduler = this.setupSchedulerPrototype(rxAny.TestScheduler, \"TestScheduler\");\n            this.prototypes.push(rxAny);\n        }\n        // Swap all methods\n\n    }, {\n        key: \"setupSchedulerMethods\",\n        value: function setupSchedulerMethods(instance, name) {\n            var self = this;\n            this.prototypes.push(instance);\n            this.logger.schedule(instance, name, null, null);\n            var proto = getPrototype(instance);\n            this.prototypes.push(proto);\n            Object.keys(proto).filter(function (key) {\n                return typeof instance[key] === \"function\";\n            }).filter(function (key) {\n                return !self.isInstrumented(instance[key], self);\n            }).forEach(function (key) {\n                // if (self.isInstrumented(instance[key]) as any as number > 0) {\n                //   console.log(\"instrumented already\", self.isInstrumented(instance[key]), \"times\")\n                // }\n                var original = instance[key];\n                // instance[key] = function (state: any, action: any, time: number) {\n                //   self.logger.schedule(instance, key, action, { state, time })\n                //   return original.apply(instance, arguments)\n                // }\n                instance[key] = function (state, action, time) {\n                    var args = [].slice.call(arguments, 0);\n                    if (key === \"scheduleAbsolute\") {\n                        console.log(\"Absolute scheduling\", args);\n                        var _newAction = self.logger.schedule(instance, key, args[2], { state: args[0], time: args[1] }) || action;\n                        if (typeof args[2] === \"function\" && typeof _newAction === \"function\") {\n                            args[2] = _newAction;\n                        }\n                        return original.apply(instance, args);\n                    }\n                    var newAction = self.logger.schedule(instance, key, action, { state: state, time: time }) || action;\n                    if (typeof action === \"function\" && typeof newAction === \"function\") {\n                        args[1] = newAction;\n                    }\n                    return original.apply(instance, args);\n                };\n                instance[key].__instrumentedBy = self;\n                instance[key].__originalFunction = original;\n            });\n        }\n        // Swap constructors\n\n    }, {\n        key: \"setupSchedulerPrototype\",\n        value: function setupSchedulerPrototype(schedulerPrototype, name) {\n            var self = this;\n            if (this.isInstrumented(schedulerPrototype, this)) {\n                return;\n            }\n            return new Proxy(schedulerPrototype, {\n                construct: function construct(target, argArray, newTarget) {\n                    var scheduler = new target(argArray);\n                    self.setupSchedulerMethods(scheduler, name);\n                    return scheduler;\n                },\n                get: function get(target, property) {\n                    if (property === \"__instrumentedBy\") {\n                        return self;\n                    }\n                    if (property === \"__originalFunction\") {\n                        return schedulerPrototype;\n                    }\n                    return target[property];\n                }\n            });\n        }\n    }, {\n        key: \"setupPrototype\",\n        value: function setupPrototype(prototype, name) {\n            var _this3 = this;\n\n            if (typeof name !== \"undefined\") {\n                prototype.__dynamicallyInstrumented = true;\n            }\n            var methods = Object.keys(prototype).filter(function (key) {\n                return typeof prototype[key] === \"function\";\n            });\n            // log, preparing for teardown\n            this.prototypes.push(prototype);\n            methods.forEach(function (key) {\n                prototype[key] = _this3.instrument(prototype[key], {\n                    methodName: key,\n                    subjectName: name || prototype.constructor.name\n                });\n            });\n            // let ctor = prototype.constructor\n            // prototype.constructor = function () {\n            //   console.log(\"ctor\", arguments)\n            //   let r = ctor.call(this, arguments)\n            //   return r\n            // }\n        }\n    }, {\n        key: \"teardown\",\n        value: function teardown() {\n            var _this4 = this;\n\n            rxAny.Subject = this.deinstrument(rxAny.Subject);\n            var properties = this.prototypes.map(function (subject) {\n                return Object.keys(subject).map(function (key) {\n                    return { key: key, subject: subject };\n                });\n            }).reduce(function (prev, next) {\n                return prev.concat(next);\n            }, []);\n            var methods = properties.filter(function (_ref3) {\n                var key = _ref3.key,\n                    subject = _ref3.subject;\n                return typeof subject[key] === \"function\";\n            });\n            // let i = 0\n            methods.forEach(function (_ref4) {\n                var key = _ref4.key,\n                    subject = _ref4.subject;\n\n                // i++\n                subject[key] = _this4.deinstrument(subject[key]);\n            });\n            // let fails = this.prototypes\n            //   .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n            //   .reduce((prev, next) => prev.concat(next), [])\n            //   .filter(({ key, subject }) => typeof subject[key] === \"function\")\n            //   .filter(({ key, subject }) => typeof subject[key].__originalFunction === \"function\").length\n            // console.log(\"Tore down\", i, \"methods, failures: \", fails)\n            this.prototypes = [];\n        }\n    }]);\n\n    return Instrumentation;\n}();\n\nexports.default = Instrumentation;\n\n/***/ }),\n\n/***/ 120:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nimportScripts(\"instrumentation/rxjs-4.1.0/rx.all.js\");\nvar treePoster_1 = __webpack_require__(46);\n__webpack_require__(10);\nvar worker_utils_1 = __webpack_require__(11);\nvar collector_1 = __webpack_require__(113);\nvar instrumentation_1 = __webpack_require__(114);\nonmessage = worker_utils_1.onWorkerMessage(function () {\n    var poster = new treePoster_1.default(function (m) {\n        return postMessage(m);\n    });\n    var collector = new collector_1.TreeCollector(poster);\n    var instrumentation = new instrumentation_1.default(instrumentation_1.defaultSubjects(Rx), collector);\n    instrumentation.setup();\n    console.info(\"Ready for RxJS 4 instrumentation\");\n    Rx.version = \"4.1.0\";\n});\n\n/***/ }),\n\n/***/ 22:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isObserver(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.onNext === \"function\";\n}\nexports.isObserver = isObserver;\nfunction isDisposable(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.dispose === \"function\";\n}\nexports.isDisposable = isDisposable;\nfunction isObservable(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.subscribe === \"function\";\n}\nexports.isObservable = isObservable;\nfunction isScheduler(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.now === \"function\" && typeof v.schedule === \"function\";\n}\nexports.isScheduler = isScheduler;\nfunction elvis(item, path) {\n    var next = (typeof item === \"undefined\" ? \"undefined\" : _typeof(item)) === \"object\" && path.length && path[0] in item ? item[path[0]] : undefined;\n    if (path.length > 1) {\n        return elvis(next, path.slice(1));\n    } else if (typeof next !== \"undefined\") {\n        return [next];\n    } else {\n        return [];\n    }\n}\nexports.elvis = elvis;\n\n/***/ }),\n\n/***/ 25:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction callRecordType(record) {\n    if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n        return undefined;\n    }\n    if (record.subjectName === \"Observable\" || record.subjectName === \"Observable.prototype\" || record.subjectName === \"ObservableBase.prototype\" || record.subjectName && record.subjectName.indexOf(\"Observable\") >= 0) {\n        if (record.method === \"subscribe\" || record.method === \"_subscribe\" || record.method === \"__subscribe\" || record.method === \"_trySubscribe\") {\n            return \"subscribe\";\n        }\n        return \"setup\";\n    } else {\n        return \"event\";\n    }\n}\nexports.callRecordType = callRecordType;\n\n/***/ }),\n\n/***/ 26:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logger_1 = __webpack_require__(6);\n\nvar Event = function () {\n    function Event(type, timing, source) {\n        _classCallCheck(this, Event);\n\n        this.type = type;\n        this.timing = timing;\n        this.source = source;\n    }\n\n    _createClass(Event, null, [{\n        key: \"fromRecord\",\n        value: function fromRecord(record, timing, source) {\n            return Event.fromCall(record.method, record.arguments, timing, source);\n        }\n    }, {\n        key: \"fromCall\",\n        value: function fromCall(method, args, timing, source) {\n            switch (method) {\n                case \"next\":\n                case \"onNext\":\n                    return new Next(timing, args[0], source);\n                case \"error\":\n                case \"onError\":\n                case \"fail\":\n                    return new Error(timing, new ErrorInstance(args[0]), source);\n                case \"complete\":\n                case \"onCompleted\":\n                    return new Complete(timing, source);\n                case \"connect\":\n                    return new Connect(timing, source);\n                case \"subscribe\":\n                case \"_subscribe\":\n                case \"__subscribe\":\n                    return new Subscribe(timing, source);\n                case \"dispose\":\n                case \"unsubscribe\":\n                    return new Dispose(timing, source);\n                default:\n                    break;\n            }\n        }\n    }, {\n        key: \"fromJson\",\n        value: function fromJson(input) {\n            switch (input.type) {\n                case \"next\":\n                    return new Next(input.timing, input.value, input.source);\n                case \"error\":\n                    return new Error(input.timing, input.error, input.source);\n                case \"complete\":\n                    return new Complete(input.timing, input.source);\n                case \"subscribe\":\n                    return new Subscribe(input.timing, input.source);\n                case \"dispose\":\n                    return new Dispose(input.timing, input.source);\n                default:\n                    return null;\n            }\n        }\n    }]);\n\n    return Event;\n}();\n\nexports.Event = Event;\n\nvar Next = function (_Event) {\n    _inherits(Next, _Event);\n\n    function Next(timing, value, source) {\n        _classCallCheck(this, Next);\n\n        var _this = _possibleConstructorReturn(this, (Next.__proto__ || Object.getPrototypeOf(Next)).call(this, \"next\", timing, source));\n\n        _this.value = logger_1.formatArguments([value]);\n        return _this;\n    }\n\n    return Next;\n}(Event);\n\nexports.Next = Next;\n\nvar ErrorInstance = function ErrorInstance(someError) {\n    _classCallCheck(this, ErrorInstance);\n\n    this.name = someError.name;\n    this.message = someError.message;\n    this.stack = someError.stack;\n};\n\nexports.ErrorInstance = ErrorInstance;\n\nvar Error = function (_Event2) {\n    _inherits(Error, _Event2);\n\n    function Error(timing, error, source) {\n        _classCallCheck(this, Error);\n\n        var _this2 = _possibleConstructorReturn(this, (Error.__proto__ || Object.getPrototypeOf(Error)).call(this, \"error\", timing, source));\n\n        _this2.error = error;\n        return _this2;\n    }\n\n    return Error;\n}(Event);\n\nexports.Error = Error;\n\nvar Complete = function (_Event3) {\n    _inherits(Complete, _Event3);\n\n    function Complete(timing, source) {\n        _classCallCheck(this, Complete);\n\n        return _possibleConstructorReturn(this, (Complete.__proto__ || Object.getPrototypeOf(Complete)).call(this, \"complete\", timing, source));\n    }\n\n    return Complete;\n}(Event);\n\nexports.Complete = Complete;\n\nvar Subscribe = function (_Event4) {\n    _inherits(Subscribe, _Event4);\n\n    function Subscribe(timing, source) {\n        _classCallCheck(this, Subscribe);\n\n        return _possibleConstructorReturn(this, (Subscribe.__proto__ || Object.getPrototypeOf(Subscribe)).call(this, \"subscribe\", timing, source));\n    }\n\n    return Subscribe;\n}(Event);\n\nexports.Subscribe = Subscribe;\n\nvar Connect = function (_Event5) {\n    _inherits(Connect, _Event5);\n\n    function Connect(timing, source) {\n        _classCallCheck(this, Connect);\n\n        return _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, \"connect\", timing, source));\n    }\n\n    return Connect;\n}(Event);\n\nexports.Connect = Connect;\n\nvar Dispose = function (_Event6) {\n    _inherits(Dispose, _Event6);\n\n    function Dispose(timing, source) {\n        _classCallCheck(this, Dispose);\n\n        return _possibleConstructorReturn(this, (Dispose.__proto__ || Object.getPrototypeOf(Dispose)).call(this, \"dispose\", timing, source));\n    }\n\n    return Dispose;\n}(Event);\n\nexports.Dispose = Dispose;\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* tslint:disable:no-namespace */\n/* tslint:disable:interface-name */\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* Get name of function */\nfunction getName() {\n    var funcNameRegex = /function (.{1,})\\(/;\n    var results = funcNameRegex.exec(this.constructor.toString());\n    return results && results.length > 1 ? results[1] : \"\";\n}\nexports.getName = getName;\nfunction UUID() {\n    /** UUID generator: http://stackoverflow.com/a/2117523/552203 */\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        // tslint:disable:no-bitwise\n        var r = Math.random() * 16 | 0;\n        var v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n        // tslint:enable:no-bitwise\n    });\n}\nexports.UUID = UUID;\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ 46:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar TreePoster = function () {\n    function TreePoster(cb) {\n        _classCallCheck(this, TreePoster);\n\n        if (typeof cb === \"function\") {\n            this.post = cb;\n        } else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.parent) {\n            this.post = function (m) {\n                return window.parent.postMessage(m, window.location.origin);\n            };\n        } else {\n            this.post = function (m) {};\n            console.error(\"Using Window.postMessage logger in non-browser environment\", new Error());\n        }\n    }\n\n    _createClass(TreePoster, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return TreePoster;\n}();\n\nexports.default = TreePoster;\n\n/***/ }),\n\n/***/ 5:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar ObservableTree = function () {\n    function ObservableTree(id, name, logger, scheduler) {\n        _classCallCheck(this, ObservableTree);\n\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObservableTree, [{\n        key: \"setSources\",\n        value: function setSources(sources) {\n            var _this = this;\n\n            this.sources = sources;\n            if (this.logger) {\n                sources.forEach(function (s) {\n                    return _this.logger.addEdge(s.id, _this.id, \"addSource\", { label: \"source\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(meta) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, meta);\n            }\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth < 100) {\n                return \"ObservableTree(\" + this.id + \", \" + this.names + \", \" + (this.sources || []).map(function (s) {\n                    return pad(_inspect(s, depth + 2, opts), 2);\n                }) + \")\";\n            }\n        }\n    }]);\n\n    return ObservableTree;\n}();\n\nexports.ObservableTree = ObservableTree;\n\nvar ObserverTree = function () {\n    function ObserverTree(id, name, logger) {\n        _classCallCheck(this, ObserverTree);\n\n        this.events = [];\n        this.id = id;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observer\");\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObserverTree, [{\n        key: \"setSink\",\n        value: function setSink(sinks) {\n            var _this2 = this;\n\n            if (this.sink === sinks[0]) {\n                return this;\n            }\n            this.sink = sinks[0];\n            sinks.forEach(function (s) {\n                return s.addInflow(_this2);\n            });\n            if (this.logger) {\n                sinks.forEach(function (s) {\n                    return _this2.logger.addEdge(_this2.id, s.id, \"addObserverDestination\", { label: \"destination\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"setOuter\",\n        value: function setOuter(outer) {\n            this.outer = outer;\n            outer.addInflow(this);\n            if (this.logger) {\n                this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" });\n            }\n            return this;\n        }\n    }, {\n        key: \"addInflow\",\n        value: function addInflow(inflow) {\n            this.inflow = this.inflow || [];\n            if (this.inflow.indexOf(inflow) >= 0) {\n                return this;\n            }\n            this.inflow.push(inflow);\n            return this;\n        }\n    }, {\n        key: \"setObservable\",\n        value: function setObservable(observable) {\n            var _this3 = this;\n\n            if (this.observable) {\n                if (this.observable !== observable[0]) {\n                    console.log(\"Adding second observable to \", this);\n                    console.log(\"becoming\", observable);\n                    console.log(\"was\", this.observable);\n                    console.log(new Error().stack.split(\"\\n\").filter(function (l) {\n                        return l.indexOf(\"instrumentation.ts\") < 0;\n                    }).slice(0, 5).join(\"\\n\"));\n                } else {\n                    return this;\n                }\n            }\n            this.observable = observable[0];\n            if (this.logger) {\n                observable.forEach(function (o) {\n                    return _this3.logger.addEdge(o.id, _this3.id, \"setObserverSource\", { label: \"observable\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(event) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, { events: event });\n            }\n            this.events.push(event);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"depth 30 reached\";\n            }\n            if (this.sink) {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 1, opts), 1) + \"\\n)\";\n            } else {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \")\";\n            }\n        }\n    }]);\n\n    return ObserverTree;\n}();\n\nexports.ObserverTree = ObserverTree;\nfunction pad(str, depth) {\n    if (depth <= 0 || !str) {\n        return str;\n    }\n    return pad(str.split(\"\\n\").map(function (l) {\n        return \"  \" + l;\n    }).join(\"\\n\"), depth - 1);\n}\nfunction _inspect(i, depth, opts) {\n    if (i && i.inspect) {\n        return i.inspect(depth, opts);\n    } else if (i && i.toString) {\n        return i.toString();\n    } else {\n        return i;\n    }\n}\n\nvar SubjectTree = function () {\n    function SubjectTree(id, name, logger, scheduler) {\n        _classCallCheck(this, SubjectTree);\n\n        this.events = [];\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n        this.observable = this;\n    }\n\n    _createClass(SubjectTree, [{\n        key: \"addSink\",\n        value: function addSink(sinks, name) {\n            var prev = this.sinks || [];\n            this.setSink(sinks, name);\n            this.sinks = prev.concat(sinks);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"Too deep\";\n            }\n            return \"SubjectTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 2, opts), 2) + \"\\n)\";\n        }\n    }]);\n\n    return SubjectTree;\n}();\n\nexports.SubjectTree = SubjectTree;\napplyMixins(SubjectTree, [ObservableTree, ObserverTree]);\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {\n            // Only mix non-defined's, causing implemented methods to act as overloads. \n            // Allows mixin to have a specialized constructor for example.\n            if (typeof derivedCtor.prototype[name] === \"undefined\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n\nvar SchedulerInfo = function SchedulerInfo(id, name, type, clock, logger) {\n    _classCallCheck(this, SchedulerInfo);\n\n    this.id = id;\n    this.name = name;\n    this.type = type;\n    this.clock = clock;\n    logger.addScheduler(this.id, this);\n};\n\nexports.SchedulerInfo = SchedulerInfo;\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar Logger = function () {\n    // tslint:disable-next-line:no-constructor-vars\n    function Logger(post) {\n        _classCallCheck(this, Logger);\n\n        this.post = post;\n    }\n\n    _createClass(Logger, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return Logger;\n}();\n\nexports.default = Logger;\nfunction formatObject(o) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (o === null) {\n        return \"null\";\n    }\n    if (levels <= 0) {\n        return (o.constructor && o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{...}\";\n    }\n    var result = (o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{\";\n    var i = 0;\n    for (var key in o) {\n        if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n            if (i > 0) {\n                result += \",\";\n            }\n            i++;\n            var padding = \"\";\n            for (var p = 0; p < depth; p++) {\n                padding += \"  \";\n            }\n            result += \"\\n\" + padding + \"\\\"\" + key + \"\\\": \" + _formatArguments([o[key]], levels - 1, depth + 1);\n        }\n    }\n    result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\";\n    return result;\n}\nexports.formatObject = formatObject;\nfunction _formatArguments(args) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    return [].map.call(args, function (a) {\n        switch (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) {\n            case \"undefined\":\n                return \"undefined\";\n            case \"object\":\n                if (Array.isArray(a)) {\n                    return \"[\" + _formatArguments(a, levels - 1, depth + 1) + \"]\";\n                } else {\n                    return formatObject(a, levels - 1, depth + 1);\n                }\n            case \"function\":\n                if (typeof a.__original === \"function\") {\n                    return a.__original.toString();\n                }\n                if (typeof a.__originalFunction === \"function\") {\n                    return a.__originalFunction.toString();\n                }\n                return a.toString();\n            case \"string\":\n                return \"\\\"\" + a.substring(0, 512) + \"\\\"\";\n            case \"boolean\":\n                return a.toString();\n            case \"number\":\n                return a;\n            default:\n                throw new TypeError(\"Invalid type \" + (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)));\n        }\n    }).join(\", \");\n}\nfunction formatArguments(args) {\n    return _formatArguments(args);\n}\nexports.formatArguments = formatArguments;\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* FlatMap extension of Array prototype */\nfunction flatMap(f) {\n    var _this = this;\n\n    return this.reduce(function (p, n, index) {\n        return p.concat(f(n, index, _this));\n    }, []);\n}\nexports.flatMap = flatMap;\nif (Object.defineProperty) {\n    Object.defineProperty(Array.prototype, \"flatMap\", {\n        configurable: false,\n        enumerable: false,\n        value: flatMap,\n        writable: false\n    });\n} else {\n    // Beware of dragons...\n    Array.prototype.flatMap = flatMap;\n}\n/* random */\nfunction endsWith(self, suffix) {\n    return self.indexOf(suffix, self.length - suffix.length) !== -1;\n}\nexports.endsWith = endsWith;\nfunction last(list) {\n    return list.length >= 1 ? list[list.length - 1] : undefined;\n}\nexports.last = last;\nfunction head(list) {\n    return list.length >= 1 ? list[0] : undefined;\n}\nexports.head = head;\nfunction getPrototype(input) {\n    return input.protoype || input.__proto__;\n}\nexports.getPrototype = getPrototype;\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// dist/worker-rx-4.1.0.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 120);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 19911d4006b8129424bd","module.exports = Rx;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"Rx\"\n// module id = 1\n// module chunks = 0 1 2 3","let scheduler: Rx.TestScheduler = null\n\nlet _ = {\n  get next(): Function {\n    return Rx.ReactiveTest.onNext\n  },\n  get complete(): Function {\n    return Rx.ReactiveTest.onCompleted\n  }\n}\n\nlet experimentProto: any = {\n  get scheduler() {\n    if (scheduler === null) {\n      scheduler = new Rx.TestScheduler()\n      scheduler.advanceTo(0)\n    }\n    return scheduler\n  },\n  get bmi() {\n    return {\n      height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(400)])),\n      weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(700)])),\n    }\n  },\n  get lottery() {\n    let start = 2034\n    let year = 1000 * 3600 * 24 * 365.25\n    return {\n      newYear$: Rx.Observable\n        .interval(year, survey.scheduler)\n        .map(t => new Date(Date.UTC(t + start, 0, 1))),\n      veryOldServer: (date: string) => {\n        let unix = new Date(date).getTime() / 1000\n        if (unix > Math.pow(2, 31)) {\n          return Rx.Observable.throw(new Error(\"Crash!\"), this.scheduler)\n        } else {\n          return this.scheduler.createHotObservable(\n            _.next(0, { msg: \"calculating\" }),\n            _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }),\n            _.complete(20)\n          )\n        }\n      },\n    }\n  },\n  get imdb() {\n    let inputStream = (text: string) => {\n      let t = 0\n      let messages = []\n      // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n      let random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89,\n        70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24,\n        15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33,\n        0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64,\n        96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3]\n      for (let i = 0; i <= text.length; i++) {\n        t += random.shift()\n        messages.push(_.next(t, text.slice(0, i)))\n      }\n      return this.scheduler.createHotObservable(...messages)\n    }\n    return {\n      _movies: [\n        \"Them\",\n        \"Lion King\",\n        \"Belle & The Beast\",\n        \"Avatar\",\n        \"Harry Potter\",\n        \"Guardians of the Galaxy\",\n        \"House of Cards\",\n        \"Spectre\",\n        \"Interstellar\",\n        \"Iron Man\",\n        \"Terminator Genisys\",\n        \"The Titanic\",\n        \"The Avengers\",\n      ],\n      findMoviesAsync: (term: string) => {\n        let result = this.imdb._movies.filter((movie: string) => movie.toLowerCase().indexOf(term.toLowerCase()) >= 0)\n        let t = 100 * result.length\n        return this.scheduler.createHotObservable(\n          _.next(t, result),\n          _.complete(t + 1)\n        )\n      },\n      inputStream,\n      johnsInput$: inputStream(\"the titanic\"),\n      render: () => { /* would append to DOM here */ },\n    }\n  },\n  get render() {\n    return () => { /* would append to DOM here */ }\n  },\n  get renderSomething() {\n    return () => { /* would append to DOM here */ }\n  },\n  get log() {\n    return () => { /* would write to console */ }\n  },\n  get showError() {\n    return () => { /* would display a warning here */ }\n  },\n  get noop() {\n    return () => { /* no operation */ }\n  },\n}\n\n// Make it global\ndeclare var experiment: any\ndeclare var survey: any\neval(\"var experiment = experimentProto\");\n(global as any).experiment = experimentProto;\neval(\"var survey = experimentProto\");\n(global as any).survey = experimentProto\n\n\n\n// WEBPACK FOOTER //\n// ./src/experiment/sample-data.ts","export type ToWorkerMessage = { type: \"run\", code: string } | { type: \"importScripts\", url: string }\n\nfunction formatError(e: Error): any {\n  return {\n    message: e.message,\n    name: e.name,\n    original: typeof (e as any).original !== \"undefined\" ? formatError((e as any).original) : undefined,\n    stack: e.stack.toString(),\n  }\n}\n\nlet scope = {}\n\n/** \n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand \n * and strip that from the errors coming from it \n */\nfunction scopedEval(code: string) {\n  // tslint:disable-next-line:only-arrow-functions\n  (function () {\n    // tslint:disable-next-line:no-eval\n    return eval(code)\n  }).call(scope)\n}\n\nfunction evalAndRepackageErrors(code: string): { type: \"result\", result: any } | { type: \"error\", error: any } {\n  try {\n    return { result: scopedEval(code), type: \"result\" }\n  } catch (e) {\n    // Infer eval location\n    try {\n      scopedEval(\"throw new Error('ERROR')\")\n    } catch (dummyError) {\n      // clean up error stack trace\n      let result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack)\n      if (result === null) {\n        return { error: e.stack, type: \"error\" }\n      }\n      let stack: string = e.stack.toString()\n      let index = stack.lastIndexOf(`at Object.<anonymous> (${result[1]})`)\n      stack = stack.substring(0, index)\n      stack = stack.split(`eval at <anonymous> (${result[1]}), `).join(\"\")\n      e.stack = stack\n    }\n    return { error: formatError(e), type: \"error\" }\n  }\n}\n\nexport function onWorkerMessage(instrument: () => void): ((e: MessageEvent) => void) {\n  return (e: MessageEvent) => {\n    let message = e.data as ToWorkerMessage\n    switch (message.type) {\n      case \"importScripts\":\n        importScripts(message.url)\n        instrument()\n        break\n      case \"run\":\n        // Execute user code\n        let result = evalAndRepackageErrors(message.code)\n        if (result.type === \"error\") {\n          (postMessage as (m: any) => void)({\n            error: result.error,\n            type: \"error\",\n          })\n        }\n        break\n      default: break\n    }\n  }\n}\n\nif (typeof postMessage === \"function\") {\n  (postMessage as Function)(\"ready\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/worker-utils.ts","import { ICallRecord, ICallStart, callRecordType } from \"../../collector/callrecord\"\nimport { RxCollector, elvis, isDisposable, isObservable, isObserver, isScheduler } from \"../../collector/collector\"\nimport { Event, IEvent, Timing } from \"../../collector/event\"\nimport { formatArguments } from \"../../collector/logger\"\nimport {\n  IObservableTree, IObserverTree, ISchedulerInfo, ITreeLogger,\n  ObservableTree, ObserverTree, SchedulerInfo, SubjectTree,\n} from \"../../oct/oct\"\nimport { getPrototype } from \"../../prelude\"\nimport * as Rx from \"rx\"\n\nlet debug = false\n\nfunction getScheduler<T>(obs: Rx.Observable<T>, record?: ICallStart): Rx.IScheduler | undefined {\n  return (obs as any).scheduler ||\n    (obs as any)._scheduler ||\n    record && [].slice.call(record.arguments, -1).filter(isScheduler)[0]\n}\n\nclass SequenceTicker {\n  public last = 0\n  public used = false\n\n  public next(): void {\n    if (this.used) {\n      this.used = false\n      this.last++\n    }\n  }\n  public get(): number {\n    this.used = true\n    return this.last\n  }\n}\n\nexport class TreeCollector implements RxCollector {\n  public static collectorId = 0\n  public hash: string\n  public collectorId: number\n  public nextId = 1\n  public logger: ITreeLogger\n  private eventSequencer = new SequenceTicker()\n\n  private schedulers: { scheduler: Rx.IScheduler, info: ISchedulerInfo }[] = []\n  private scheduler?: { scheduler: Rx.IScheduler, info: ISchedulerInfo }\n\n  public constructor(logger: ITreeLogger) {\n    this.collectorId = TreeCollector.collectorId++\n    this.hash = this.collectorId ? `__thash${this.collectorId}` : \"__thash\"\n    this.logger = logger\n  }\n\n  /**\n   * Used to wrap arguments of higher order functions. Consider:\n   *   \n   *   let a = Rx.Observable.just(1)\n   *   a.flatMap((nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n   * \n   * now wrapHigherOrder is called like this:\n   * \n   *   wrapHigherOrder(a, (nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n   * \n   * so we can inject a custom function which can link the result of the lambda to `a`.\n   * \n   * @param subject observable to link to\n   * @param fn function (or any other argument) to wrap\n   */\n  public wrapHigherOrder(call: ICallRecord, fn: Function | any): Function | any {\n    let self = this\n    if (typeof fn === \"function\" && isObservable(call.subject)) {\n      function replacementLambda() {\n        let result = fn.apply(this, arguments)\n        if (typeof result === \"object\" && isObservable(result)) {\n          return self.observableWrapper(result, call.subject, () => call.returned)\n        }\n        return result\n      }\n      (replacementLambda as any).__original = fn\n      return replacementLambda\n    }\n    return fn\n  }\n\n  public schedule(scheduler: Rx.IScheduler, method: string, action: Function, state: any): Function | undefined {\n    let info = this.tag(scheduler)\n    let self = this\n    if (method.startsWith(\"schedule\") && method !== \"scheduleRequired\") {\n      // tslint:disable-next-line:only-arrow-functions\n      return function () {\n        let justAssigned = self.scheduler = { scheduler, info: info as ISchedulerInfo }\n        self.eventSequencer.next()\n        let result = action.apply(this, arguments)\n        if (self.scheduler === justAssigned) {\n          self.scheduler = undefined\n        }\n        return result\n      }\n    }\n  }\n\n  public before(record: ICallStart, parents?: ICallStart[]): this {\n    switch (callRecordType(record)) {\n      case \"subscribe\":\n        let obs = this.tagObservable(record.subject);\n        [].slice.call(record.arguments, 0, 1)\n          .filter(isObserver)\n          .map((s: Rx.Observer<any>) => {\n            record.arguments[0] = this.subscriptionWrapper(record.arguments[0], this.tagObserver(s, record)[0])\n            return s\n          })\n          .flatMap((s: any) => this.tagObserver(s, record)).forEach((sub: any) => {\n            obs.forEach(observable => {\n              if (observable instanceof SubjectTree) {\n                // Special case for subjects\n                observable.addSink(([sub]), \" subject\")\n                sub.setObservable([observable])\n              } else if (observable instanceof ObservableTree) {\n                sub.setObservable([observable])\n              }\n            })\n          })\n        break\n      case \"setup\":\n        this.tagObservable(record.subject)\n      default: break\n    }\n    return this\n  }\n\n  public getEventReason(record: ICallStart): string | undefined {\n    return [record.parent, record.parent && record.parent.parent]\n      .filter(r => r && isObserver(r.subject) && this.hasTag(r.subject))\n      .map(r => this.tag(r.subject).id)[0]\n  }\n\n  public addEvent(observer: IObserverTree, event: IEvent, value?: any) {\n    if (typeof event === \"undefined\") { return }\n\n    // Enrich higher order events\n    if (event.type === \"next\" && isObservable(value)) {\n      event.value = {\n        id: this.tag(value).id,\n        type: value.constructor.name,\n      } as any as string\n    }\n\n    // Ignore 2nd subscribe (subscribe & _subscribe are instrumented both)\n    if (observer.events.length === 1 && observer.events[0].type === \"subscribe\" && event.type === \"subscribe\") {\n      return\n    }\n\n    if (!observer.inflow || observer.inflow.length === 0) {\n      this.eventSequencer.next()\n    }\n\n    event.timing = this.getTiming()\n    observer.addEvent(event)\n  }\n\n  public after(record: ICallRecord): void {\n    switch (callRecordType(record)) {\n      case \"subscribe\":\n        if (isDisposable(record.returned)) {\n          record.returned = this.disposableWrapper(record.returned, record.arguments[0])\n        }\n        break\n      case \"setup\":\n        this.tagObservable(record.returned, record)\n      default: break\n    }\n  }\n\n  private hasTag(input: any): boolean {\n    return typeof input === \"object\" && input !== null && typeof (input as any)[this.hash] !== \"undefined\"\n  }\n\n  private tag(input: any, record?: ICallStart): IObserverTree | IObservableTree | ISchedulerInfo | undefined {\n    let tree: IObserverTree | IObservableTree\n    if (typeof input === \"undefined\") {\n      return undefined\n    }\n    if (typeof (input as any)[this.hash] !== \"undefined\") {\n      return (input as any)[this.hash]\n    }\n\n    if (isObserver(input) && isObservable(input)) {\n      (input as any)[this.hash] = tree = new SubjectTree(`${this.nextId++}`,\n        input.constructor.name, this.logger, this.getScheduler(input))\n      return tree\n    }\n    if (isObservable(input)) {\n      (input as any)[this.hash] = tree = new ObservableTree(`${this.nextId++}`,\n        input.constructor.name, this.logger, this.getScheduler(input, record)\n      )\n      return tree\n    }\n    if (isObserver(input)) {\n      (input as any)[this.hash] = tree = new ObserverTree(`${this.nextId++}`,\n        input.constructor.name, this.logger)\n      return tree\n    }\n    if (isScheduler(input)) {\n      let scheduler = input as Rx.IScheduler\n      let type: \"immediate\" | \"recursive\" | \"timeout\" | \"virtual\"\n      switch (getPrototype(scheduler).constructor.name) {\n        case \"ImmediateScheduler\":\n          type = \"immediate\"\n          break\n        case \"DefaultScheduler\":\n          type = \"timeout\"\n          break\n        case \"CurrentThreadScheduler\":\n          type = \"recursive\"\n          break\n        case \"TestScheduler\":\n          type = \"virtual\"\n          break\n        default:\n          if (debug) { console.debug(\"unknown scheduler type\", getPrototype(scheduler).constructor.name) }\n          type = \"virtual\"\n          break\n      }\n      let clock = scheduler.now()\n      let info = new SchedulerInfo(\n        `${this.nextId++}`, getPrototype(scheduler).constructor.name,\n        type, clock, this.logger\n      );\n      (input as any)[this.hash] = info\n      this.schedulers.push({ scheduler, info })\n      return info\n    }\n  }\n\n  private getScheduler(input: Rx.Observable<any>, record?: ICallStart): ISchedulerInfo {\n    if (isObservable(input) && getScheduler(input, record)) {\n      return this.tag(getScheduler(input, record)) as ISchedulerInfo\n    }\n  }\n\n  private getTiming(): Timing {\n    let clocks: { [id: string]: number } = { tick: this.eventSequencer.get() }\n    if (this.scheduler) {\n      clocks[this.scheduler.info.id] = this.scheduler.scheduler.now()\n      return Object.assign({\n        scheduler: this.scheduler.info.id,\n        clocks,\n      })\n    }\n    return {\n      clocks,\n      scheduler: \"tick\",\n    }\n  }\n\n  private tagObserver(input: any, record?: ICallStart, traverse: boolean = true): IObserverTree[] {\n    if (isObserver(input)) {\n\n      // Rx specific: unfold AutoDetachObserver's, \n      while (traverse && input && input.constructor.name === \"AutoDetachObserver\" && input.observer) {\n        input = input.observer\n      }\n\n      let tree = this.tag(input) as IObserverTree\n\n      // Find sink\n      let sinks = this.getSink(input, record)\n      sinks.forEach(([how, sink]) => {\n        tree.setSink([this.tag(sink) as IObserverTree])\n      })\n\n      return [tree]\n    }\n    return []\n  }\n\n  private getSink<T>(input: Rx.Observer<T>, record?: ICallStart): [string, Rx.Observer<T>][] {\n    // Rx specific: InnerObservers have references to their sinks via a AutoDetachObserver\n    let list = elvis(input, [\"o\", \"observer\"]) // InnerObservers\n      .concat(elvis(input, [\"_o\", \"observer\"])) // InnerObservers\n      .concat(elvis(input, [\"parent\"])) // what was this again?\n      .concat(elvis(input, [\"_s\", \"o\"])) // ConcatObserver\n      .concat(elvis(input, [\"observer\"])) // ConcatObserver\n      .map(s => [\" via o.observer\", s])\n    // If no sinks could be found via object attributes, try to find it via the call stack\n    if (record && !list.length && callStackDepth(record) > 2 && !(isObservable(input) && isObserver(input))) {\n      list.push(...sequenceUnique(\n        _ => _.sub,\n        generate(record, _ => _.parent)\n          .map(rec => ({\n            sub: rec.arguments[0] as Rx.Observer<T>,\n          }))\n          .filter(_ => isObserver(_.sub) && _.sub !== input)\n      ).slice(1, 2).map(_ => [\" via callstack\", _.sub]))\n    }\n\n    return list.slice(0, 1).flatMap(([how, sink]: [string, Rx.Observer<T>]) => {\n      if (sink.constructor.name === \"AutoDetachObserver\") {\n        return this.getSink(sink)\n      } else {\n        return [[how, sink] as [string, Rx.Observer<T>]]\n      }\n    })\n  }\n\n  private tagObservable(input: any, callRecord?: ICallStart): IObservableTree[] {\n    if (isObservable(input)) {\n      let wasTagged = this.hasTag(input)\n      let tree = this.tag(input, callRecord) as IObservableTree\n      if (!wasTagged) {\n        /* TODO find other way: this is a shortcut to prevent MulticastObservable._fn1 to show up */\n        if (callRecord && callRecord.method[0] !== \"_\") {\n          while (callRecord && isObservable((callRecord as ICallRecord).returned) && callRecord.method[0] !== \"_\") {\n            tree.addMeta({\n              calls: {\n                subject: `callRecord.subjectName ${this.hasTag(callRecord.subject) && this.tag(callRecord.subject).id}`,\n                args: formatArguments(callRecord.arguments),\n                method: callRecord.method,\n              },\n            })\n\n            // if (typeof callRecord.parent !== \"undefined\" && isObservable(callRecord.parent.subject)) {\n            callRecord = callRecord.parent\n            // } else {\n            //   callRecord = undefined\n            // }\n          }\n        }\n        if ((input as any).source) {\n          tree.setSources(this.tagObservable((input as any).source))\n        } else if ((input as any)._sources) {\n          tree.setSources((input as any)._sources.flatMap((s: any) => this.tagObservable(s)))\n        }\n      }\n      if (getScheduler(input)) {\n        this.tag(getScheduler(input))\n      }\n      return [tree]\n    }\n    return []\n  }\n\n  private observableWrapper<T, R>(target: T, context: Rx.Observable<R>, outerContext: () => Rx.Observable<R>): T {\n    function subscribe() {\n      if (debug) {\n        console.debug(\"Wrap this higher order subscribe method\\n\",\n          target.constructor.name,\n          context.constructor.name,\n          outerContext().constructor.name)\n      }\n      let result = (target as any).subscribe.apply(target, arguments)\n      return result\n    }\n    return new Proxy(target, {\n      get: (obj: any, name: string) => {\n        if (name === \"isScoped\") { return true }\n        if (name === \"subscribe\" && \"subscribe\" in target) {\n          return subscribe\n        }\n        return obj[name]\n      },\n    })\n  }\n\n  // Wrap this around a Subscription to log onNext, onError, onComplete, dispose calls\n  private subscriptionWrapper<T>(target: Rx.Observer<T>, tree: IObserverTree) {\n    if ((target as any).__isSubscriptionWrapper) {\n      return target\n    }\n    // Ensure only one single Proxy is attached to the IObserverTree\n    if ((tree as any).proxy) {\n      return target\n    }\n    let collector = this\n    let events = [\"onNext\", \"onError\", \"onCompleted\", \"dispose\"]\n    tree.addEvent(Event.fromCall(\"subscribe\", undefined, this.getTiming()))\n    let proxy = new Proxy(target, {\n      get: (obj: any, name: string) => {\n        let original = obj[name]\n        if (name === \"__isSubscriptionWrapper\") { return true }\n        if (typeof original === \"function\" && events.indexOf(name) >= 0) {\n          function proxy() {\n            collector.addEvent(tree, Event.fromCall(name, [].slice.call(arguments, 0), undefined), arguments[0])\n            return original.apply(this, arguments)\n          }\n          return proxy\n        }\n        return original\n      },\n    });\n    (tree as any).proxy = proxy\n    return proxy\n  }\n\n  // Wrap this around a Disposable to log dispose calls onto the supplied observer\n  private disposableWrapper<T>(target: Rx.Disposable, observer?: any) {\n    if ((target as any).__isDisposableWrapper) {\n      return target\n    }\n    let tree: IObserverTree[] = isObserver(observer) ? this.tagObserver(observer) : []\n    let collector = this\n    return new Proxy(target, {\n      get: (obj: any, name: string) => {\n        let original = obj[name]\n        if (name === \"__isDisposableWrapper\") { return true }\n        if (typeof original === \"function\" && name === \"dispose\") {\n          function proxy() {\n            collector.addEvent(tree[0], Event.fromCall(name, [].slice.call(arguments, 0), undefined))\n            return original.apply(this, arguments)\n          }\n          return proxy\n        }\n        return original\n      },\n    })\n  }\n\n}\n\nfunction callStackDepth(record: ICallStart): number {\n  return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent)\n}\n\nfunction generate<T>(seed: T, next: (acc: T) => T | undefined | null): T[] {\n  if (typeof seed === \"undefined\" || seed === null) {\n    return []\n  } else {\n    return [seed, ...generate(next(seed), next)]\n  }\n}\n\nfunction sequenceUnique<T, K>(keySelector: (e: T) => K, list: T[]): T[] {\n  let filtered = [] as T[]\n  for (let v of list) {\n    if (filtered.length === 0 || keySelector(filtered[filtered.length - 1]) !== keySelector(v)) {\n      filtered.push(v)\n    }\n  }\n  return filtered\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/collector.ts","import { ICallRecord, ICallStart } from \"../../collector/callrecord\"\nimport { RxCollector } from \"../../collector/collector\"\nimport \"../../utils\"\nimport * as Rx from \"rx\"\n\nconst rxAny: any = Rx as any\n\nexport let defaultSubjects = (rxAny: any) => ({\n  Observable: Rx.Observable,\n  \"Observable.prototype\": rxAny.Observable.prototype,\n  \"ConnectableObservable.prototype\": rxAny.ConnectableObservable.prototype,\n  \"ObservableBase.prototype\": rxAny.ObservableBase.prototype,\n  // \"AbstractObserver.prototype\": rxAny.internals.AbstractObserver.prototype,\n  // \"AnonymousObserver.prototype\": rxAny.AnonymousObserver.prototype,\n  \"Subject.prototype\": rxAny.Subject.prototype,\n})\n\nexport let defaultSchedulerFactory: { [key: string]: any } = Object.keys(Rx.Scheduler)\n  .filter(name => typeof (Rx.Scheduler as any)[name] === \"object\")\n  .filter(name => (Rx.Scheduler as any)[name].__proto__.constructor.name.indexOf(\"Scheduler\") >= 0)\n  .reduce((p, name) => {\n    p[name] = (Rx.Scheduler as any)[name]\n    return p\n  }, {} as any)\n\nexport const HASH = \"__hash\"\nexport const IGNORE = \"__ignore\"\n\nfunction now() {\n  return typeof performance !== \"undefined\" ? performance.now() : new Date().getTime()\n}\n\n/* tslint:disable:interface-name */\nexport interface Function {\n  caller?: Function\n  __originalFunction?: Function | null\n  apply(subject: any, args: any[] | IArguments): any\n}\n\nfunction hasRxObservablePrototype(input: any): boolean {\n  return typeof input === \"object\" && rxAny.Observable.prototype.isPrototypeOf(input)\n}\n\nfunction startsWith(input: string, matcher: string) {\n\n  let r = input.substr(0, matcher.length) === matcher\n  return r\n}\n\nfunction detachedScopeProxy<T>(input: T): T {\n  let hashes: { [id: string]: number } = {}\n  if ((input as any).__detached === true) {\n    return input\n  }\n  return new Proxy(input, {\n    get: (target: any, property: PropertyKey): any => {\n      if (property === \"__detached\") {\n        return true\n      }\n      if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n        return hashes[property]\n      }\n      return (target as any)[property]\n    },\n    set: (target, property, value): boolean => {\n      if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n        hashes[property] = value\n      }\n      return true\n    },\n  })\n}\n\n/**\n * Tweaks specific for RxJS 4\n */\nfunction rxTweaks<T>(call: ICallStart): void {\n  // Detach reuse of NeverObservable\n  let fields: [any, PropertyKey][] = []\n  fields.push([call, \"subject\"], [call, \"returned\"])\n  fields.push(...[].map.call(call.arguments, (a: any, i: number) => [call.arguments, i]))\n  fields.forEach(([subject, prop]) => {\n    if (\n      typeof subject[prop] !== \"undefined\" && subject[prop] !== null &&\n      subject[prop].constructor.name === \"NeverObservable\"\n    ) {\n      subject[prop] = detachedScopeProxy(subject[prop])\n    }\n  })\n  // Other tweaks here...\n}\n\n// class Ticker {\n//   private tick: number = 0\n//   private timeout?: Rx.IDisposable\n//   private next: () => void\n//   constructor() {\n//     this.next = this.nextTick.bind(this)\n//   }\n//   public get() {\n//     if (!this.timeout) {\n//       this.timeout = Rx.Scheduler.currentThread.schedule({}, () => { this.next(); return Rx.Disposable.empty })\n//       // this.timeout = setTimeout(this.next, 0)\n//     }\n//     return this.tick\n//   }\n//   private nextTick() {\n//     this.tick++\n//     this.timeout = undefined\n//   }\n// }\n\n// let ticker = new Ticker()\n\nexport function getPrototype(input: any): any {\n  return input.prototype || input.__proto__\n}\n\nlet i = 0\n\nexport default class Instrumentation {\n  public logger: RxCollector\n  public open: any[] = []\n  public stackTraces: boolean = true\n\n  private subjects: { [name: string]: any; }\n  private calls: (ICallStart | ICallRecord)[] = []\n\n  private prototypes: any[] = []\n\n  constructor(subjects: { [name: string]: any; } = defaultSubjects, logger: RxCollector) {\n    this.subjects = subjects\n    this.logger = logger\n    Object.keys(subjects).slice(0, 1).forEach((s: string) => subjects[s][IGNORE] = true)\n  }\n\n  public isInstrumented(fn: Function, by?: Instrumentation): boolean {\n    if (typeof by === \"undefined\") {\n      return ((\n        typeof fn.__originalFunction === \"function\" ?\n          1 + (this.isInstrumented(fn.__originalFunction) as any) as number :\n          0)\n      ) as any as boolean\n    }\n    if ((fn as any).__instrumentedBy === by) { return true }\n    let orig = (fn as any).__originalFunction\n    return typeof orig === \"function\" && this.isInstrumented(orig, by)\n  }\n\n  /* tslint:disable:only-arrow-functions */\n  /* tslint:disable:no-string-literal */\n  /* tslint:disable:no-string-literal */\n  public instrument(fn: Function, extras: { [key: string]: string; }): Function {\n    let calls = this.calls\n    let logger = this.logger\n    let open = this.open\n    let self = this\n\n    let instrumented = new Proxy(fn, {\n      apply: (target: any, thisArg: any, argumentsList: any[]) => {\n        // console.log(target.caller)\n\n        // find more\n        argumentsList\n          .filter(hasRxObservablePrototype)\n          .filter((v: any) => !this.isInstrumented(v))\n          .forEach((t: any) => this.setupPrototype(t))\n\n        let call: ICallStart = {\n          arguments: [].slice.call(argumentsList, 0),\n          childs: [],\n          id: i++,\n          method: extras[\"methodName\"],\n          stack: self.stackTraces ? undefined : undefined, // new Error().stack : undefined,\n          subject: thisArg,\n          subjectName: extras[\"subjectName\"],\n          tick: 0, // ticker.get(),\n          time: now(),\n        }\n\n        // Prepare\n        calls.push(call)\n        if (open.length > 0) {\n          call.parent = open[open.length - 1]\n          call.parent.childs.push(call)\n        }\n        open.push(call)\n\n        // Nicen up Rx performance tweaks\n        rxTweaks(call)\n\n        // Actual method\n        let instanceLogger = logger.before(call, open.slice(0, -1))\n        let returned = target.apply(call.subject, [].map.call(\n          call.arguments,\n          instanceLogger.wrapHigherOrder.bind(instanceLogger, call))\n        )\n\n        let end: ICallRecord = call as ICallRecord\n        end.returned = returned\n\n        // Nicen up Rx performance tweaks\n        rxTweaks(end)\n\n        instanceLogger.after(end);\n\n        // find more\n        ([end.returned])\n          .filter(hasRxObservablePrototype)\n          .filter((v: any) => !this.isInstrumented(v))\n          .forEach((t: any) => this.setupPrototype(t))\n\n        // Cleanup\n        open.pop()\n        return end.returned\n      },\n      construct: (target: { new (...args: any[]): any }, args) => {\n        console.warn(\"TODO, instrument constructor\", target, args)\n        return new target(...args)\n      },\n      get: (target: any, property: PropertyKey): any => {\n        if (property === \"__instrumentedBy\") { return self }\n        if (property === \"__originalFunction\") { return fn }\n        return (target as any)[property]\n      },\n    })\n    return instrumented\n  }\n\n  public deinstrument(fn: Function): Function {\n    return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn\n  }\n  /* tslint:enable:only-arrow-functions */\n  /* tslint:enable:no-string-literal */\n  /* tslint:enable:no-string-literal */\n\n  public setup(): void {\n    // Observables\n    Object.keys(this.subjects)\n      .forEach(name => this.setupPrototype(this.subjects[name], name))\n\n    // Subjects\n    rxAny.Subject = this.instrument(rxAny.Subject, {\n      methodName: \"new\",\n      subjectName: \"Rx.Subject\",\n    })\n\n    // Schedulers\n    Object.keys(defaultSchedulerFactory)\n      .forEach(name => this.setupSchedulerMethods(defaultSchedulerFactory[name], name))\n    rxAny.TestScheduler = this.setupSchedulerPrototype(rxAny.TestScheduler, \"TestScheduler\")\n    this.prototypes.push(rxAny)\n  }\n\n  // Swap all methods\n  public setupSchedulerMethods(instance: any, name?: string) {\n    let self = this\n    this.prototypes.push(instance)\n    this.logger.schedule(instance, name, null, null)\n    let proto = getPrototype(instance)\n    this.prototypes.push(proto)\n    Object.keys(proto)\n      .filter(key => typeof instance[key] === \"function\")\n      .filter(key => !self.isInstrumented(instance[key], self))\n      .forEach(key => {\n        // if (self.isInstrumented(instance[key]) as any as number > 0) {\n        //   console.log(\"instrumented already\", self.isInstrumented(instance[key]), \"times\")\n        // }\n        let original = instance[key]\n\n        // instance[key] = function (state: any, action: any, time: number) {\n        //   self.logger.schedule(instance, key, action, { state, time })\n        //   return original.apply(instance, arguments)\n        // }\n\n        instance[key] = function (state: any, action: any, time: number) {\n          let args = [].slice.call(arguments, 0)\n          if (key === \"scheduleAbsolute\") {\n            console.log(\"Absolute scheduling\", args)\n            let newAction = self.logger.schedule(instance, key, args[2], { state: args[0], time: args[1] }) || action\n            if (typeof args[2] === \"function\" && typeof newAction === \"function\") { args[2] = newAction }\n            return original.apply(instance, args)\n          }\n          let newAction = self.logger.schedule(instance, key, action, { state, time }) || action\n          if (typeof action === \"function\" && typeof newAction === \"function\") { args[1] = newAction }\n          return original.apply(instance, args)\n        }\n\n        instance[key].__instrumentedBy = self\n        instance[key].__originalFunction = original\n      })\n  }\n\n  // Swap constructors\n  public setupSchedulerPrototype(schedulerPrototype: any, name?: string) {\n    let self = this\n    if (this.isInstrumented(schedulerPrototype, this)) {\n      return\n    }\n    return new Proxy(schedulerPrototype, {\n      construct: (target, argArray, newTarget) => {\n        let scheduler = new target(argArray)\n        self.setupSchedulerMethods(scheduler, name)\n        return scheduler\n      },\n      get: (target: any, property: PropertyKey): any => {\n        if (property === \"__instrumentedBy\") { return self }\n        if (property === \"__originalFunction\") { return schedulerPrototype }\n        return (target as any)[property]\n      },\n    })\n  }\n\n  public setupPrototype(prototype: any, name?: string) {\n    if (typeof name !== \"undefined\") {\n      prototype.__dynamicallyInstrumented = true\n    }\n    let methods = Object.keys(prototype)\n      .filter((key) => typeof prototype[key] === \"function\")\n\n    // log, preparing for teardown\n    this.prototypes.push(prototype)\n\n    methods.forEach(key => {\n      prototype[key] = this.instrument(prototype[key], {\n        methodName: key,\n        subjectName: name || prototype.constructor.name,\n      })\n    })\n\n    // let ctor = prototype.constructor\n    // prototype.constructor = function () {\n    //   console.log(\"ctor\", arguments)\n    //   let r = ctor.call(this, arguments)\n    //   return r\n    // }\n  }\n\n  public teardown(): void {\n    rxAny.Subject = this.deinstrument(rxAny.Subject)\n\n    let properties: { key: string, subject: any }[] = this.prototypes\n      .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n      .reduce((prev, next) => prev.concat(next), [])\n\n    let methods = properties\n      .filter(({ key, subject }) => typeof subject[key] === \"function\")\n\n    // let i = 0\n    methods.forEach(({ key, subject }) => {\n      // i++\n      subject[key] = this.deinstrument(subject[key])\n    })\n\n    // let fails = this.prototypes\n    //   .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n    //   .reduce((prev, next) => prev.concat(next), [])\n    //   .filter(({ key, subject }) => typeof subject[key] === \"function\")\n    //   .filter(({ key, subject }) => typeof subject[key].__originalFunction === \"function\").length\n\n    // console.log(\"Tore down\", i, \"methods, failures: \", fails)\n\n    this.prototypes = []\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/instrumentation.ts","importScripts(\"instrumentation/rxjs-4.1.0/rx.all.js\")\nimport TreePoster from \"../../collector/treePoster\"\nimport \"../../experiment/sample-data\"\nimport { onWorkerMessage } from \"../worker-utils\"\nimport { TreeCollector } from \"./collector\"\nimport Instrumentation, { defaultSubjects } from \"./instrumentation\"\n\nonmessage = onWorkerMessage(() => {\n  let poster = new TreePoster(m => (postMessage as (m: any) => void)(m))\n  let collector = new TreeCollector(poster)\n  let instrumentation: Instrumentation = new Instrumentation(defaultSubjects(Rx), collector)\n  instrumentation.setup()\n  console.info(\"Ready for RxJS 4 instrumentation\");\n  (Rx as any).version = \"4.1.0\"\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/worker.ts","import { ICallStart } from \"./callrecord\"\nimport { RxCollector } from \"./ICollector\"\nimport * as Rx from \"rx\"\n\ntype Group = {\n  call: ICallStart\n  id: number\n  used: boolean\n}\n\nexport function isObserver<T>(v: any): v is Rx.Observer<T> & any {\n  return typeof v === \"object\" && v !== null && typeof v.onNext === \"function\"\n}\n\nexport function isDisposable(v: any): v is Rx.Subscription & any {\n  return typeof v === \"object\" && v !== null && typeof v.dispose === \"function\"\n}\n\nexport function isObservable<T>(v: any): v is Rx.Observable<T> {\n  return typeof v === \"object\" && v !== null && typeof v.subscribe === \"function\"\n}\n\nexport function isScheduler(v: any): v is Rx.IScheduler & any {\n  return typeof v === \"object\" && v !== null && typeof v.now === \"function\" && typeof v.schedule === \"function\"\n}\n\nexport function elvis(item: any, path: string[]): any[] {\n  let next = typeof item === \"object\" && path.length && path[0] in item ? item[path[0]] : undefined\n  if (path.length > 1) {\n    return elvis(next, path.slice(1))\n  } else if (typeof next !== \"undefined\") {\n    return [next]\n  } else {\n    return []\n  }\n}\n\nexport { RxCollector }\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/collector.ts","import { StackFrame } from \"./stackframe\"\n\nexport type ICallRecord = ICallStart & ICallEnd\n\nexport interface ICallStart {\n  id: number | string | null\n  subject: any\n  subjectName: string\n  method: string\n  arguments: any[]\n  stack?: StackFrame | string\n  time: number\n  parent?: ICallStart\n  childs: (ICallRecord | ICallStart)[]\n  tick: number\n}\n\nexport interface ICallEnd {\n  returned: any | null\n}\n\ntype CallRecordType = \"setup\" | \"subscribe\" | \"event\"\n\nexport function callRecordType(record: ICallStart) {\n  if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n    return undefined\n  }\n  if (record.subjectName === \"Observable\" ||\n    record.subjectName === \"Observable.prototype\" ||\n    record.subjectName === \"ObservableBase.prototype\" ||\n    record.subjectName &&\n    record.subjectName.indexOf(\"Observable\") >= 0\n  ) {\n    if (record.method === \"subscribe\" ||\n      record.method === \"_subscribe\" ||\n      record.method === \"__subscribe\" ||\n      record.method === \"_trySubscribe\"\n    ) {\n      return \"subscribe\"\n    }\n    return \"setup\"\n  } else {\n    return \"event\"\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/callrecord.ts","// tslint:disable:no-constructor-vars\nimport { ICallStart } from \"./callrecord\"\nimport { formatArguments } from \"./logger\"\n\nexport type IEventType = \"next\" | \"error\" | \"complete\" | \"subscribe\" | \"dispose\" | \"connect\"\n\nexport type IEvent = Next<any> | Subscribe | Complete | Error | Dispose | Connect\n\nexport type Timing = {\n  scheduler: string\n  clocks: { [id: string]: number }\n}\n\nexport class Event {\n  public static fromRecord(record: ICallStart, timing: Timing, source?: string): IEvent | null {\n    return Event.fromCall(record.method, record.arguments, timing, source)\n  }\n  public static fromCall(method: string, args: any[], timing: Timing, source?: string): IEvent {\n    switch (method) {\n      case \"next\":\n      case \"onNext\":\n        return new Next(timing, args[0], source)\n      case \"error\":\n      case \"onError\":\n      case \"fail\":\n        return new Error(timing, new ErrorInstance(args[0]), source)\n      case \"complete\":\n      case \"onCompleted\":\n        return new Complete(timing, source)\n      case \"connect\":\n        return new Connect(timing, source)\n      case \"subscribe\":\n      case \"_subscribe\":\n      case \"__subscribe\":\n        return new Subscribe(timing, source)\n      case \"dispose\":\n      case \"unsubscribe\":\n        return new Dispose(timing, source)\n      default: break\n      // console.log(\"Unknown event\", record)\n    }\n  }\n  public static fromJson(input: any): IEvent | null {\n    switch (input.type) {\n      case \"next\": return new Next(input.timing, input.value, input.source)\n      case \"error\": return new Error(input.timing, input.error, input.source)\n      case \"complete\": return new Complete(input.timing, input.source)\n      case \"subscribe\": return new Subscribe(input.timing, input.source)\n      case \"dispose\": return new Dispose(input.timing, input.source)\n      default: return null\n    }\n  }\n  constructor(public type: IEventType, public timing: Timing, public source?: string) { }\n}\n\nexport class Next<T> extends Event {\n  public value: string\n  public type: \"next\"\n  constructor(timing: Timing, value: T, source?: string) {\n    super(\"next\", timing, source)\n    this.value = formatArguments([value])\n  }\n}\n\nexport class ErrorInstance {\n  public name: string\n  public message: string\n  public stack: string\n  public constructor(someError: SyntaxError) {\n    this.name = someError.name\n    this.message = someError.message\n    this.stack = someError.stack\n  }\n}\n\nexport class Error extends Event {\n  public error: ErrorInstance\n  public type: \"error\"\n  constructor(timing: Timing, error: ErrorInstance, source?: string) {\n    super(\"error\", timing, source)\n    this.error = error\n  }\n}\n\nexport class Complete extends Event {\n  public type: \"complete\"\n  constructor(timing: Timing, source?: string) { super(\"complete\", timing, source) }\n}\n\nexport class Subscribe extends Event {\n  public type: \"subscribe\"\n  constructor(timing: Timing, source?: string) { super(\"subscribe\", timing, source) }\n}\n\nexport class Connect extends Event {\n  public type: \"connect\"\n  constructor(timing: Timing, source?: string) { super(\"connect\", timing, source) }\n}\n\nexport class Dispose extends Event {\n  public type: \"dispose\"\n  constructor(timing: Timing, source?: string) { super(\"dispose\", timing, source) }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/event.ts","/* tslint:disable:no-namespace */\n/* tslint:disable:interface-name */\n\n/* Extension of Rx */\ndeclare global {\n  namespace Rx {\n    interface Observable<T> { }\n    interface Observer<T> {\n      source?: Observable<any>\n      o?: Observer<any>\n    }\n    interface ObservableStatic {\n      prototype: any\n    }\n    interface IScheduler { }\n    interface Subscription { }\n  }\n}\n\ninterface ObservableStatic {\n  prototype: any\n}\n\n/* Get name of function */\nexport function getName(this: Function) {\n  let funcNameRegex = /function (.{1,})\\(/\n  let results = (funcNameRegex).exec((this).constructor.toString())\n  return (results && results.length > 1) ? results[1] : \"\"\n}\n\nexport function UUID() {\n  /** UUID generator: http://stackoverflow.com/a/2117523/552203 */\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    // tslint:disable:no-bitwise\n    let r = Math.random() * 16 | 0\n    let v = c === \"x\" ? r : (r & 0x3 | 0x8)\n    return v.toString(16)\n    // tslint:enable:no-bitwise\n  })\n}\n\ndeclare module \"graphlib\" {\n  interface Graph {\n    // new (options: { compound?: boolean, multigraph?: boolean }): Graph\n    // height: number\n    // width: number\n    graph(): {\n      width: number, height: number,\n      ranker: \"network-simplex\" | \"tight-tree\" | \"longest-path\"\n      rankdir: \"TB\" | \"BT\" | \"LR\" | \"RL\"\n    }\n    filterNodes(filter: (node: string) => boolean): Graph\n    setGraph(g: {}): void\n    setDefaultEdgeLabel(callback: () => void): any\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\n\nexport default class TreePoster implements ITreeLogger {\n  private post: (message: any) => void\n  constructor(cb?: (message: any) => void) {\n    if (typeof cb === \"function\") {\n      this.post = cb\n    } else if (typeof window === \"object\" && window.parent) {\n      this.post = m => window.parent.postMessage(m, window.location.origin)\n    } else {\n      this.post = m => { /* intentionally left blank */ }\n      console.error(\"Using Window.postMessage logger in non-browser environment\", new Error())\n    }\n  }\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/treePoster.ts","import { IEvent } from \"../collector/event\"\n\nexport type Id = string\n\nexport interface MethodCall {\n  method: string\n  args: IArguments\n}\n\nexport interface IObservableTree {\n  id: Id\n  names?: string[]\n  calls?: MethodCall[]\n  sources?: IObservableTree[]\n  scheduler?: ISchedulerInfo\n  setSources(sources: IObservableTree[]): IObservableTree\n  addMeta(meta: any): IObservableTree\n}\n\nexport interface IObserverTree {\n  id: Id\n  names?: string[]\n  observable: IObservableTree\n  sink?: IObserverTree\n  inflow?: IObserverTree[]\n  events: IEvent[]\n  setOuter(sinks: IObserverTree): IObserverTree\n  setSink(sinks: IObserverTree[]): IObserverTree\n  addInflow(inflow: IObserverTree): IObserverTree\n  setObservable(observable: IObservableTree[]): IObserverTree\n  addEvent(event: IEvent): IObserverTree\n}\n\n//                     O->O *-*    | O->S 1-1            | S->S *-*                \nexport type EdgeType = \"addSource\" | \"setObserverSource\" | \"addObserverDestination\" | \"addObserverOuter\"\nexport type NodeType = \"observable\" | \"subject\" | \"observer\"\n\nexport interface ITreeLogger {\n  addNode(id: Id, type: NodeType, timing?: ISchedulerInfo): void\n  addMeta(id: Id, meta: any): void\n  addEdge(v: Id, w: Id, type: EdgeType, meta?: any): void\n  addScheduler(id: Id, scheduler: ISchedulerInfo): void\n  addContraction(id: Id, nodes: Id[]): void\n}\n\nexport class ObservableTree implements IObservableTree {\n  public id: Id\n  public names?: string[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSources(sources: IObservableTree[]): IObservableTree {\n    this.sources = sources\n    if (this.logger) {\n      sources.forEach(s => this.logger.addEdge(s.id, this.id, \"addSource\", { label: \"source\" }))\n    }\n    return this\n  }\n\n  public addMeta(meta: any): IObservableTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, meta)\n    }\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth < 100) {\n      return `ObservableTree(${this.id}, ${this.names}, ${\n        (this.sources || []).map(s => pad(inspect(s, depth + 2, opts), 2))\n        })`\n    }\n  }\n}\n\nexport class ObserverTree implements IObserverTree {\n  public id: Id\n  public names?: string[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public outer?: IObserverTree\n  public inflow?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger) {\n    this.id = id\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observer\")\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSink(sinks: IObserverTree[]): IObserverTree {\n    if (this.sink === sinks[0]) {\n      return this\n    }\n    this.sink = sinks[0]\n    sinks.forEach(s => s.addInflow(this))\n    if (this.logger) {\n      sinks.forEach(s => this.logger.addEdge(this.id, s.id, \"addObserverDestination\", { label: \"destination\" }))\n    }\n    return this\n  }\n\n  public setOuter(outer: IObserverTree): IObserverTree {\n    this.outer = outer\n    outer.addInflow(this)\n    if (this.logger) {\n      this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" })\n    }\n    return this\n  }\n\n  public addInflow(inflow: IObserverTree) {\n    this.inflow = this.inflow || []\n    if (this.inflow.indexOf(inflow) >= 0) {\n      return this\n    }\n    this.inflow.push(inflow)\n    return this\n  }\n  public setObservable(observable: IObservableTree[]): IObserverTree {\n    if (this.observable) {\n      if (this.observable !== observable[0]) {\n        console.log(\"Adding second observable to \", this)\n        console.log(\"becoming\", observable)\n        console.log(\"was\", this.observable)\n        console.log(new Error().stack.split(\"\\n\").filter(l => l.indexOf(\"instrumentation.ts\") < 0).slice(0, 5).join(\"\\n\"))\n      } else {\n        return this\n      }\n    }\n    this.observable = observable[0]\n    if (this.logger) {\n      observable.forEach(o => this.logger.addEdge(o.id, this.id, \"setObserverSource\", { label: \"observable\" }))\n    }\n    return this\n  }\n\n  public addEvent(event: IEvent): IObserverTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, { events: event })\n    }\n    this.events.push(event)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"depth 30 reached\"\n    }\n    if (this.sink) {\n      return `ObserverTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 1, opts), 1)}\\n)`\n    } else {\n      return `ObserverTree(${this.id}, ${this.names})`\n    }\n  }\n}\n\nfunction pad(str: string, depth: number): string {\n  if (depth <= 0 || !str) {\n    return str\n  }\n  return pad(str.split(\"\\n\").map(l => \"  \" + l).join(\"\\n\"), depth - 1)\n}\n\nfunction inspect(i: any, depth: number, opts: any): string {\n  if (i && i.inspect) {\n    return i.inspect(depth, opts)\n  } else if (i && i.toString) {\n    return i.toString()\n  } else {\n    return i\n  }\n}\n\nexport class SubjectTree implements ObservableTree, ObserverTree {\n  public id: Id\n  public names?: string[]\n  public args: IArguments\n  public inflow?: IObserverTree[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public sinks?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  // Mixin Observable & Observer methods\n  public setSink: (sinks: IObserverTree[], name?: string) => this\n  public setOuter: (sinks: IObserverTree) => this\n  public addInflow: (inflow: IObserverTree) => this\n  public setObservable: (observable: IObservableTree[]) => IObserverTree\n  public setSources: (sources: IObservableTree[]) => IObservableTree\n  public addMeta: (meta: any) => this\n  public addEvent: (event: IEvent) => IObserverTree\n  public logger?: ITreeLogger\n\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) {\n      this.names = [name]\n    }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n    this.observable = this\n  }\n\n  public addSink(sinks: IObserverTree[], name?: string) {\n    let prev = this.sinks || []\n    this.setSink(sinks, name)\n    this.sinks = prev.concat(sinks)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"Too deep\"\n    }\n    return `SubjectTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 2, opts), 2)}\\n)`\n  }\n}\n\napplyMixins(SubjectTree, [ObservableTree, ObserverTree])\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      // Only mix non-defined's, causing implemented methods to act as overloads. \n      // Allows mixin to have a specialized constructor for example.\n      if (typeof derivedCtor.prototype[name] === \"undefined\") {\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n      }\n    })\n  })\n}\n\nexport type SchedulerType = \"immediate\" | \"recursive\" | \"timeout\" | \"virtual\"\n\nexport type ISchedulerInfo = {\n  id: string\n  name: string\n  type: SchedulerType\n  clock: number\n}\n\nexport class SchedulerInfo implements ISchedulerInfo {\n  public id: string\n  public name: string\n  public type: SchedulerType\n  public clock: number\n\n  constructor(\n    id: string, name: string,\n    type: SchedulerType,\n    clock: number, logger?: ITreeLogger\n  ) {\n    this.id = id\n    this.name = name\n    this.type = type\n    this.clock = clock\n    logger.addScheduler(this.id, this)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/oct/oct.ts","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\nimport { IEvent } from \"./event\"\n\nexport default class Logger implements ITreeLogger {\n  // tslint:disable-next-line:no-constructor-vars\n  constructor(private post: (m: any) => void) {}\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\nexport function formatObject(o: any, levels: number = 2, depth: number = 0): string {\n  if (o === null) { return \"null\" }\n  if (levels <= 0) {\n    return `${\n      o.constructor && o.constructor.name !== \"Object\" ?\n        `[${o.constructor.name}] ` :\n        \"\"\n      }{...}`\n  }\n\n  let result = `${o.constructor.name !== \"Object\" ? `[${o.constructor.name}] ` : \"\"}{`\n  let i = 0\n  for (let key in o) {\n    if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n      if (i > 0) { result += \",\" }\n      i++\n      let padding = \"\"\n      for (let p = 0; p < depth; p++) { padding += \"  \" }\n      result += `\\n${padding}\"${key}\": ${_formatArguments([o[key]], levels - 1, depth + 1)}`\n    }\n  }\n  result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\"\n  return result\n}\n\nfunction _formatArguments(args: IArguments | any[], levels: number = 2, depth: number = 0): string {\n  return [].map.call(args, (a: any) => {\n    switch (typeof a) {\n      case \"undefined\": return \"undefined\"\n      case \"object\":\n        if (Array.isArray(a)) {\n          return `[${_formatArguments(a, levels - 1, depth + 1)}]`\n        } else {\n          return formatObject(a, levels - 1, depth + 1)\n        }\n      case \"function\":\n        if (typeof a.__original === \"function\") {\n          return a.__original.toString()\n        }\n        if (typeof a.__originalFunction === \"function\") {\n          return a.__originalFunction.toString()\n        }\n        return a.toString()\n      case \"string\":\n        return `\"${a.substring(0, 512)}\"`\n      case \"boolean\":\n        return a.toString()\n      case \"number\":\n        return a\n      default: throw new TypeError(`Invalid type ${typeof a}`)\n    }\n  }).join(\", \")\n}\n\nexport function formatArguments(args: IArguments | any[]): string {\n  return _formatArguments(args)\n}\n\nexport type Node = {\n  id: number\n  type: \"node\"\n  node: {\n    name: string\n  }\n}\nexport type Edge = {\n  type: \"edge\"\n  edge: {\n    v: number\n    w: number\n    label: SubscriptionLinkLabel | SubscriptionHigherOrderLinkLabel | ObservableTimingLabel,\n    reason: string\n  }\n  group?: number\n  groups?: number[]\n}\n\nexport type NodeLabel = {\n  group?: number\n  groups?: number[]\n  type: \"label\"\n  label: SubcriptionLabel | ObservableLabel | EventLabel\n  node: number\n}\n\nexport type ObservableTimingLabel = {\n  time: number\n  type: \"observable link\"\n}\n\nexport type SubcriptionLabel = {\n  id: number\n  type: \"subscription\"\n}\n\nexport type SubscriptionLinkLabel = {\n  type: \"subscription sink\"\n  v: number\n  w: number\n}\n\nexport type SubscriptionHigherOrderLinkLabel = {\n  type: \"higherOrderSubscription sink\",\n  id: number\n  parent: number\n}\n\nexport type EventLabel = {\n  event: IEvent\n  subscription: number\n  type: \"event\"\n}\n\nexport type ObservableLabel = {\n  args: any\n  method: string\n  type: \"observable\"\n}\n\nexport type Message = Node | Edge | NodeLabel\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/logger.ts","/* FlatMap extension of Array prototype */\nexport function flatMap<T, R>(this: T[], f: (t: T, index: number, all: T[]) => R[]): R[] {\n  return this.reduce((p: R[], n: T, index: number) => p.concat(f(n, index, this)), [])\n}\n\n// tslint:disable-next-line:no-namespace\ndeclare global {\n  interface Array<T> {\n    flatMap<R>(f: (t: T, index: number, all: T[]) => R[]): Array<R>\n  }\n}\n\nif (Object.defineProperty) {\n  Object.defineProperty(Array.prototype, \"flatMap\", {\n    configurable: false,\n    enumerable: false,\n    value: flatMap,\n    writable: false,\n  })\n} else {\n  // Beware of dragons...\n  Array.prototype.flatMap = flatMap\n}\n\n/* random */\nexport function endsWith(self: string, suffix: string): boolean {\n  return self.indexOf(suffix, self.length - suffix.length) !== -1\n}\n\nexport function last<T>(list: T[]): T {\n  return list.length >= 1 ? list[list.length - 1] : undefined\n}\n\nexport function head<T>(list: T[]): T {\n  return list.length >= 1 ? list[0] : undefined\n}\n\nexport function getPrototype(input: any): any {\n  return input.protoype || input.__proto__\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/prelude.ts"],"sourceRoot":""}